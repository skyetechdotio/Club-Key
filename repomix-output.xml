This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .specstory/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor/
  rules/
    1password-cli.mdc
    repomix.mdc
backend/
  notifications/
    email.ts
    index.ts
    password-reset.ts
  routes/
    notifications.ts
  auth.ts
  booking-service.ts
  database-storage.ts
  db.js
  db.ts
  express-app.js
  firebase-auth.js
  firebase.js
  index.ts
  mongo-storage.js
  new-express-app.js
  new-index.js
  new-main.js
  new-reminder-service.js
  new-routes.js
  reminder-service.ts
  routes.ts
  start-mongo.js
  storage.ts
  vite.ts
frontend/
  public/
    favicon.svg
  src/
    assets/
      backgrounds/
        green-foliage.svg
      golf-course-1.svg
      logo.svg
      new-logo.svg
    components/
      _dev_examples/
        QueryExample.tsx
        SanityCheckComponent.tsx
        SupabaseExample.tsx
      auth/
        auth-modal.tsx
        CheckEmailModal.tsx
        login-form.tsx
        password-reset-form.tsx
        register-form.tsx
      chat/
        chat-window.tsx
        message-input.tsx
        message-list.tsx
      dashboard/
        host-calendar.tsx
      home/
        become-host.tsx
        cta-section.tsx
        featured-tee-times.tsx
        hero-section.tsx
        how-it-works.tsx
        testimonials.tsx
        top-destinations.tsx
      listings/
        search-filters.tsx
        tee-time-card.tsx
      notifications/
        notification-panel.tsx
      tee-times/
        create-tee-time-form.tsx
      ui/
        accordion.tsx
        alert-dialog.tsx
        alert.tsx
        aspect-ratio.tsx
        avatar-group.tsx
        avatar.tsx
        badge.tsx
        breadcrumb.tsx
        button.tsx
        calendar.tsx
        card.tsx
        carousel.tsx
        chart.tsx
        checkbox.tsx
        collapsible.tsx
        command.tsx
        context-menu.tsx
        dialog.tsx
        drawer.tsx
        dropdown-menu.tsx
        form.tsx
        hover-card.tsx
        input-otp.tsx
        input.tsx
        label.tsx
        menubar.tsx
        navigation-menu.tsx
        pagination.tsx
        popover.tsx
        progress.tsx
        radio-group.tsx
        resizable.tsx
        scroll-area.tsx
        select.tsx
        separator.tsx
        sheet.tsx
        sidebar.tsx
        skeleton.tsx
        slider.tsx
        switch.tsx
        table.tsx
        tabs.tsx
        textarea.tsx
        toast.tsx
        toaster.tsx
        toggle-group.tsx
        toggle.tsx
        tooltip.tsx
        visually-hidden.tsx
      custom-link.tsx
      scroll-restoration.tsx
    context/
      auth-context.tsx
      chat-context.tsx
    hooks/
      use-animations.ts
      use-auth.tsx
      use-chat.tsx
      use-mobile.tsx
      use-notifications.tsx
      use-profile.tsx
      use-tee-times.tsx
      use-toast.ts
    layouts/
      Footer.tsx
      Navbar.tsx
    lib/
      queryClient.ts
      supabaseClient.ts
      utils.ts
    pages/
      about.tsx
      basic-profile-edit.tsx
      checkout.tsx
      contact.tsx
      cookie-policy.tsx
      create-listing.tsx
      dashboard.tsx
      EditListingPage.tsx
      help.tsx
      home.tsx
      messages.tsx
      not-found.tsx
      notifications.tsx
      pre-checkout.tsx
      press.tsx
      privacy-policy.tsx
      profile-edit.tsx
      profile-onboarding.tsx
      profile.tsx
      tee-time-details.tsx
      tee-times.tsx
      terms-of-service.tsx
      UpdatePasswordPage.tsx
    styles/
      global.css
    types/
      react-helmet.d.ts
    App.tsx
    main.tsx
  index.html
migrations/
  meta/
    _journal.json
    0000_snapshot.json
    0001_snapshot.json
  0000_ancient_nehzno.sql
  0001_left_barracuda.sql
shared/
  schema.ts
sql_scripts/
  database-rls-policies.sql
  insert-test-data.sql
  missing_reset_token_columns.sql
  README.md
.cursorindexingignore
.gitignore
.replit
components.json
drizzle.config.ts
package.json
postcss.config.js
README.md
tailwind.config.ts
tsconfig.json
vercel.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/1password-cli.mdc">
---
description: This rule ensures 1Password CLI is used when running applications that require secrets. It's triggered when environment files are detected in the workspace
globs: 
alwaysApply: false
---
# This rule ensures 1Password CLI is used when running applications that require secrets
# It's triggered when environment files are detected in the workspace
type: AutoAttached
globs:
  - "**/.env*"  # Catch all .env files including .env.local, .env.development, etc.
  - "**/frontend/.env*"
  - "**/backend/.env*"
  - "**/api/.env*"  # Common folder name for backend services

---

## 1Password CLI Secret Management

When helping you run services for this project, I'll ensure proper secret management using 1Password CLI.

### Detection

I'll identify when secret management is needed based on:
- Presence of `.env` files (or variants like `.env.local`, `.env.development`)
- Configuration files referring to environment variables
- References to secret management in project documentation or scripts

### Command Modification

When I detect that your application needs access to secrets, I'll:

1. Prefix all execution commands with `op run --`
   - Transform: `npm run dev` → `op run -- npm run dev`
   - Transform: `python manage.py runserver` → `op run -- python manage.py runserver`
   - Transform: `docker-compose up` → `op run -- docker-compose up`

2. For Docker-based applications:
   - Recommend: `op run -- docker-compose up`
   - Or suggest environment passing: `op run -- docker run --env-file <(op run --env-file=.env -- env) ...`

3. For specific secret references in `.env` files using `op://` syntax:
   - Basic usage: `op run -- your-command`
   - When explicit processing is needed: `op run --env-file=.env -- your-command`

### Common Command Patterns

| Original Command | 1Password-Secured Command |
|------------------|---------------------------|
| `npm start` | `op run -- npm start` |
| `yarn dev` | `op run -- yarn dev` |
| `pnpm run dev` | `op run -- pnpm run dev` |
| `python app.py` | `op run -- python app.py` |
| `go run main.go` | `op run -- go run main.go` |
| `node server.js` | `op run -- node server.js` |

I'll always prioritize secure secret management when helping you run applications.
</file>

<file path=".cursor/rules/repomix.mdc">
---
description: When the user asks for help with Repomix or wants to generate a Repomix output for an LLM, use the following guidelines to construct the appropriate commands or provide suggestions
globs: 
alwaysApply: false
---
# This rule activates when working with projects where Repomix might be relevant
type: UserRule
name: Repomix CLI Assistant
globs:
  - "**/*.js"
  - "**/*.ts"
  - "**/*.jsx"
  - "**/*.tsx"
  - "**/*.vue"
  - "**/*.py"
  - "**/*.go"
  - "**/*.java"
  - "**/*.rb"
  - "**/package.json"
  - "**/repomix.config.json"

---

## Repomix CLI Assistant Guidelines

When the user asks for help with Repomix or wants to generate a Repomix output for an LLM, use the following guidelines to construct the appropriate commands or provide suggestions:

### 1. Full Project Scan
- When the user requests to "repomix the project," "run a full repomix," "repomix all files," or similar:
  - Primary command: `repomix`
  - This generates a `repomix-output.xml` file by default
  - Ask if a specific output format is needed (e.g., `--style markdown`)
  - Check if a `repomix.config.json` might already define output preferences

### 2. Targeted Scans
- For specific parts of a project (frontend, backend, specific features/directories):
  - Single directory: `repomix path/to/your/directory`
    - Example: `repomix frontend/` or `repomix src/features/authentication/`
  - Multiple files/directories or complex patterns:
    - Use glob patterns with `--include` flag
    - Example: `repomix --include "src/features/my-feature/**/*.ts,src/components/related-to-feature/**/*.vue"`
  - For "extract features and their dependencies" requests:
    - Ask for clarification on relevant paths or primary files/folders
    - Help construct appropriate glob patterns

### 3. Code Compression
- When token count is mentioned as a concern, output is too large for an LLM, or compression is explicitly requested:
  - **Always offer or include the `--compress` flag**
  - Example: `repomix --compress` or `repomix path/to/directory --compress`
  - Proactively suggest: "This selection might result in a high token count. Would you like to enable code compression (`--compress`) to reduce it?"

### 4. Processing Remote Repositories
- For GitHub URLs or shorthand references like `username/repo`:
  - Use the `--remote` flag
  - Recommend `npx` for one-off remote processing
  - Examples:
    - `npx repomix --remote https://github.com/yamadashy/repomix`
    - `npx repomix --remote username/repo-name`
    - `npx repomix --remote https://github.com/username/repo-name/tree/main/src/app --compress`
  - Confirm desired output location or if default is acceptable

### 5. General Command Construction
- Combine options as needed for complex requests
  - Example: "repomix the frontend of remote repo X, compress it, output as markdown"
  - Command: `npx repomix --remote https://github.com/user/repo/tree/main/frontend --compress --style markdown --output frontend-compressed.md`
- Clarify if Repomix is globally installed (`repomix ...`) or if `npx repomix ...` is preferred

### 6. Config File Usage
- When a `repomix.config.json` exists or is mentioned:
  - Default behavior: Repomix automatically uses it if in the project root
  - Specify custom location: `repomix --config path/to/repomix.config.json`
  - For complex projects: Suggest creating config files for commonly-used scan patterns

### 7. Output Formats
- Default: XML (`repomix-output.xml`)
- Markdown: `--style markdown` (recommended for LLM consumption)
- JSON: `--style json` (useful for programmatic processing)
- Custom file naming: `--output filename.extension`

### 8. Troubleshooting Guidance
- For "Permission denied" errors: Suggest `chmod +x` for script files or running with proper permissions
- For "Command not found": Verify installation with `npx repomix --version` or suggest installation
- For excessive output size: Suggest more specific targeting with `--include` or enabling `--compress`
- For timeout issues with remote repos: Recommend cloning first, then running locally
</file>

<file path="backend/notifications/email.ts">
import { User } from '@shared/schema';
import sgMail from '@sendgrid/mail';
⋮----
// Initialize SendGrid
⋮----
interface EmailParams {
  to: string;
  subject: string;
  text?: string;
  html?: string;
}
⋮----
/**
 * Send an email notification
 */
export async function sendEmail(params: EmailParams): Promise<boolean>
⋮----
text: params.text || '', // Provide fallback empty string
html: params.html || '', // Provide fallback empty string
⋮----
/**
 * Send a booking confirmation email to a guest
 */
export async function sendBookingConfirmation(user: User, bookingId: number, teeTimeListing: any): Promise<boolean>
⋮----
/**
 * Send a booking status update email to a guest
 */
export async function sendBookingStatusUpdate(user: User, bookingId: number, status: string, teeTimeListing: any): Promise<boolean>
⋮----
// Capitalize first letter of status
⋮----
// Status-specific messaging
⋮----
/**
 * Send a payment confirmation to host when funds are released from escrow
 */
export async function sendHostPaymentConfirmation(user: User, bookingId: number, teeTimeListing: any, amount: number): Promise<boolean>
⋮----
// Make sure we have a name to use
⋮----
/**
 * Send a notification to a host when their tee time is booked
 */
export async function sendHostBookingNotification(user: User, bookingId: number, teeTimeListing: any, guestName: string): Promise<boolean>
⋮----
// Make sure we have a name to use
⋮----
/**
 * Send a reminder email one week before tee time
 */
export async function sendOneWeekReminderEmail(user: User, bookingId: number, teeTimeListing: any): Promise<boolean>
⋮----
// Make sure we have a name to use
⋮----
/**
 * Send a reminder email one day before tee time
 */
export async function sendOneDayReminderEmail(user: User, bookingId: number, teeTimeListing: any): Promise<boolean>
⋮----
// Make sure we have a name to use
⋮----
/**
 * Send a welcome email to a new user
 */
export async function sendWelcomeEmail(user: User): Promise<boolean>
⋮----
// Make sure we have a name to use
⋮----
/**
 * Send a new message notification email
 */
export async function sendNewMessageNotification(user: User, senderName: string, messagePreview: string): Promise<boolean>
⋮----
// Make sure we have a name to use
</file>

<file path="backend/notifications/index.ts">
import { storage } from '../storage';
import { User, Booking, Message } from '@shared/schema';
import { 
  sendBookingConfirmation, 
  sendBookingStatusUpdate, 
  sendNewMessageNotification,
  sendHostBookingNotification,
  sendOneWeekReminderEmail,
  sendOneDayReminderEmail,
  sendHostPaymentConfirmation
} from './email';
⋮----
/**
 * Send notifications for a new booking
 */
export async function notifyNewBooking(bookingId: number): Promise<void>
⋮----
// Get booking details
⋮----
// Get tee time details
⋮----
// Get host details
⋮----
// Get guest details
⋮----
// Get club details
⋮----
// Create in-app notification for host
⋮----
// Create in-app notification for guest
⋮----
// Prepare tee time details for emails
⋮----
// Send email notification to guest
⋮----
// Send email notification to host
⋮----
// Schedule reminder emails
⋮----
/**
 * Send notifications for booking status changes
 */
export async function notifyBookingStatusChange(bookingId: number, newStatus: string): Promise<void>
⋮----
// Get booking details
⋮----
// Get tee time details
⋮----
// Get host details
⋮----
// Get guest details
⋮----
// Get club details
⋮----
// Create in-app notification for guest
⋮----
// Send email notification to guest
⋮----
/**
 * Send notifications for new messages
 */
export async function notifyNewMessage(messageId: number): Promise<void>
⋮----
// Get message details
⋮----
// Get sender details
⋮----
// Get receiver details
⋮----
// Create in-app notification
⋮----
// Create a preview of the message (first 50 characters)
⋮----
// Send email notification
⋮----
/**
 * Send payment confirmation to host
 */
export async function notifyHostPayment(bookingId: number, amount: number): Promise<void>
⋮----
// Get booking details
⋮----
// Get tee time details
⋮----
// Get host details
⋮----
// Get club details
⋮----
// Create in-app notification for host
⋮----
// Send email notification
⋮----
// Function removed to fix duplicate implementation
⋮----
/**
 * Schedule reminder emails for tee time booking
 */
export async function scheduleReminderEmails(bookingId: number): Promise<void>
⋮----
// Get booking details
⋮----
// Get tee time details
⋮----
// Calculate one week before
⋮----
// Calculate one day before
⋮----
// Update booking with reminder dates
⋮----
/**
 * Send one week reminder notification
 */
export async function sendOneWeekReminder(bookingId: number): Promise<void>
⋮----
// Get booking details
⋮----
// Check if reminder is already sent
⋮----
// Get tee time details
⋮----
// Get guest details
⋮----
// Get club details
⋮----
// Create in-app notification for guest
⋮----
// Send email notification
⋮----
// Mark reminder as sent
⋮----
/**
 * Send one day reminder notification
 */
export async function sendOneDayReminder(bookingId: number): Promise<void>
⋮----
// Get booking details
⋮----
// Check if reminder is already sent
⋮----
// Get tee time details
⋮----
// Get guest details
⋮----
// Get club details
⋮----
// Create in-app notification for guest
⋮----
// Send email notification
⋮----
// Mark reminder as sent
⋮----
/**
 * Create an in-app notification
 */
export async function createNotification(data: {
  userId: number;
  title: string;
  message: string;
  type: string;
  relatedId: number;
  isRead: boolean;
}): Promise<void>
</file>

<file path="backend/notifications/password-reset.ts">
import { User } from '@shared/schema';
import { sendEmail } from './email';
⋮----
/**
 * Send a password reset email with a reset token
 */
export async function sendPasswordResetEmail(user: User, resetToken: string): Promise<boolean>
⋮----
// Make sure we have a name to use
⋮----
// Generate the reset URL with the token
⋮----
/**
 * Send a password reset success confirmation email
 */
export async function sendPasswordResetSuccessEmail(user: User): Promise<boolean>
⋮----
// Make sure we have a name to use
</file>

<file path="backend/routes/notifications.ts">
import { Router, Request, Response } from 'express';
import { storage } from '../storage';
import { notifyNewBooking, notifyBookingStatusChange, notifyNewMessage } from '../notifications';
⋮----
// Get notifications for the current user
⋮----
// Get unread notification count
⋮----
// Mark a notification as read
⋮----
// Mark all notifications as read
⋮----
// Manual notification trigger endpoints (for testing or admin use)
</file>

<file path="backend/auth.ts">
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import { Express, Request, Response, NextFunction } from "express";
import session from "express-session";
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
import { storage } from "./storage";
import { User as UserType } from "@shared/schema";
import connectPg from "connect-pg-simple";
import { sendPasswordResetEmail, sendPasswordResetSuccessEmail } from "./notifications/password-reset";
⋮----
interface User extends UserType {}
⋮----
// Password hashing
export async function hashPassword(password: string): Promise<string>
⋮----
async function comparePasswords(supplied: string, stored: string): Promise<boolean>
⋮----
// Check if the stored password has the expected format
⋮----
// Additional validation to prevent buffer length errors
⋮----
// Ensure both buffers have the same length
⋮----
export function setupAuth(app: Express)
⋮----
// Setup session store with PostgreSQL
⋮----
maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
⋮----
// Configure local strategy for authentication via email/password
⋮----
// Serialize user to store in session
⋮----
// Deserialize user from session
⋮----
// Set up authentication routes
⋮----
// Check if username exists and is already taken (if provided)
⋮----
// Check if email already exists
⋮----
// Hash password
⋮----
// If no username is provided, generate one from email (for backward compatibility)
⋮----
// Create a username from email (remove @ and domain, add random digits)
⋮----
// Create user with onboarding flag
⋮----
// Log in the user automatically
⋮----
// Return user without password
⋮----
// Return user without password
⋮----
// Return user without password
⋮----
// Password reset request - step 1: User requests reset
⋮----
// Check if user exists
⋮----
// Generate a reset token
⋮----
const resetTokenExpiry = new Date(Date.now() + 60 * 60 * 1000); // 1 hour from now
⋮----
// Store the reset token in the database for the user
⋮----
// Send email with reset token
⋮----
// Log for development
⋮----
// For security, always return success even if the email doesn't exist
// This prevents email enumeration attacks
⋮----
// Password reset request - step 2: User submits new password with token
⋮----
// Find user with this reset token
⋮----
// Check if token is expired
⋮----
// Hash the new password
⋮----
// Update the user's password and clear reset token fields
⋮----
// Send confirmation email
⋮----
// Middleware to check if user is authenticated
export const isAuthenticated = (req: Request, res: Response, next: NextFunction) =>
⋮----
// Middleware to check if user is a host
export const isHost = (req: Request, res: Response, next: NextFunction) =>
</file>

<file path="backend/booking-service.ts">
import schedule from 'node-schedule';
import { storage } from './storage';
⋮----
/**
 * The BookingService class handles the lifecycle of bookings,
 * including automatic expiration of pending bookings and status transitions.
 * This mimics the functionality of Timekit's booking management system.
 */
export class BookingService
⋮----
private expirationJob!: schedule.Job; // Using definite assignment assertion
⋮----
/**
   * Create a booking service
   * @param expirationMinutes - The number of minutes after which pending bookings expire
   */
constructor(expirationMinutes: number = 15)
⋮----
/**
   * Initialize the booking service
   * Sets up scheduled jobs for pending booking expiration
   */
public init(): void
⋮----
// Schedule job to run every minute
⋮----
// Initial run
⋮----
/**
   * Stop the booking service
   */
public stop(): void
⋮----
/**
   * Find and expire pending bookings that are older than the specified expiration time
   */
private async expirePendingBookings(): Promise<void>
⋮----
// Get pending bookings older than the expiration time
⋮----
// Process each expired booking
⋮----
// Update booking status to 'expired'
⋮----
// Update tee time status back to 'available'
⋮----
/**
   * Create a pending booking for a tee time
   * This mimics Timekit's booking creation flow
   */
public async createPendingBooking(teeTimeId: number, guestId: number, numberOfPlayers: number, totalPrice: number): Promise<any>
⋮----
// First change tee time status to pending
⋮----
// Enhanced status checking with better error messages
⋮----
// Check if there's a pending booking that can be released
⋮----
// Check how old the pending status is based on createdAt
⋮----
// If the pending status is older than 10 minutes, consider it stale and reset
⋮----
// Now the tee time is available, so we can continue
⋮----
// Mark tee time as pending to prevent double bookings (like Timekit's locking feature)
⋮----
// Create the booking with pending status
⋮----
// If anything goes wrong, ensure tee time is marked as available again
⋮----
/**
   * Confirm a pending booking after successful payment
   * This mimics Timekit's confirmation workflow
   */
public async confirmBooking(bookingId: number, paymentIntentId: string): Promise<any>
⋮----
// Add additional checks to handle race conditions
⋮----
// Check if another booking has already been confirmed for this tee time
⋮----
// Update this booking to cancelled since we can't confirm it
⋮----
// Allow confirmation of bookings in these states only
⋮----
// If there's already a payment intent saved, don't overwrite it
⋮----
// Update booking status to confirmed
⋮----
// Update tee time status to booked
⋮----
/**
   * Cancel a booking and make the tee time available again
   * This mimics Timekit's cancellation workflow
   */
public async cancelBooking(bookingId: number, reason?: string): Promise<any>
⋮----
// Update booking status to cancelled
⋮----
// Update tee time status to available
⋮----
// Export a singleton instance
</file>

<file path="backend/database-storage.ts">
import { db } from './db';
import { eq, and, or, desc, lte } from 'drizzle-orm';
import { 
  Profile, InsertProfile, UpsertProfile,
  Club, InsertClub, 
  UserClub, InsertUserClub,
  TeeTimeListing, InsertTeeTimeListing,
  Booking, InsertBooking,
  Review, InsertReview,
  Message, InsertMessage,
  Notification, InsertNotification,
  profiles, clubs, userClubs, teeTimeListing, bookings, reviews, messages, notifications
} from '@shared/schema';
import { IStorage } from './storage';
import { pool } from './db';
import connectPg from 'connect-pg-simple';
import session from 'express-session';
⋮----
export class DatabaseStorage implements IStorage
⋮----
constructor()
⋮----
async getUser(id: string): Promise<Profile | undefined>
⋮----
async getUserByUsername(username: string): Promise<Profile | undefined>
⋮----
// Email lookup - not available in profiles table (handled by Supabase Auth)
async getUserByEmail(email: string): Promise<Profile | undefined>
⋮----
// Email is handled by Supabase Auth, not stored in profiles
// This method should not be used with the new schema
⋮----
// Google ID lookup - not available in profiles table (handled by Supabase Auth)
async getUserByGoogleId(googleId: string): Promise<Profile | undefined>
⋮----
// Google ID is handled by Supabase Auth, not stored in profiles
⋮----
// Reset token lookup - not available in profiles table (handled by Supabase Auth)
async getUserByResetToken(resetToken: string): Promise<Profile | undefined>
⋮----
// Reset tokens are handled by Supabase Auth, not stored in profiles
⋮----
async createUser(insertUser: InsertProfile): Promise<Profile>
⋮----
async updateUser(id: string, userData: Partial<Profile>): Promise<Profile | undefined>
⋮----
// Add updatedAt to force a cache refresh
⋮----
async updateUserStripeInfo(id: string, stripeInfo:
⋮----
async upsertUser(upsertUser: UpsertProfile &
⋮----
// Try to update the existing user
⋮----
// If update fails, proceed to insert
⋮----
// If update didn't return a user, insert a new one
⋮----
async getClub(id: number): Promise<Club | undefined>
⋮----
async getClubs(): Promise<Club[]>
⋮----
async createClub(insertClub: InsertClub): Promise<Club>
⋮----
async getUserClubs(userId: string): Promise<UserClub[]>
⋮----
async addUserToClub(insertUserClub: InsertUserClub): Promise<UserClub>
⋮----
async getTeeTimeListing(id: number): Promise<TeeTimeListing | undefined>
⋮----
async getTeeTimeListingsByHostId(hostId: string): Promise<TeeTimeListing[]>
⋮----
async getTeeTimeListingsByClubId(clubId: number): Promise<TeeTimeListing[]>
⋮----
async getAvailableTeeTimeListings(): Promise<TeeTimeListing[]>
⋮----
async createTeeTimeListing(insertTeeTimeListing: InsertTeeTimeListing): Promise<TeeTimeListing>
⋮----
async updateTeeTimeListing(id: number, teeTimeListingData: Partial<TeeTimeListing>): Promise<TeeTimeListing | undefined>
⋮----
// Ensure we're not trying to set updatedAt since it doesn't exist in database schema
⋮----
async getBooking(id: number): Promise<Booking | undefined>
⋮----
async getBookingsByGuestId(guestId: string): Promise<Booking[]>
⋮----
async getBookingsByTeeTimeId(teeTimeId: number): Promise<Booking[]>
⋮----
async getBookingsByPaymentIntent(paymentIntentId: string): Promise<Booking[]>
⋮----
async createBooking(insertBooking: InsertBooking): Promise<Booking>
⋮----
async updateBooking(id: number, bookingData: Partial<Booking>): Promise<Booking | undefined>
⋮----
async updateBookingStatus(id: number, status: string): Promise<Booking | undefined>
⋮----
async getReview(id: number): Promise<Review | undefined>
⋮----
async getReviewsByTargetId(targetId: string, targetType: string): Promise<Review[]>
⋮----
async getReviewsByReviewerId(reviewerId: string): Promise<Review[]>
⋮----
async createReview(insertReview: InsertReview): Promise<Review>
⋮----
async getMessage(id: number): Promise<Message | undefined>
⋮----
async getMessagesByBookingId(bookingId: number): Promise<Message[]>
⋮----
async getConversation(userOneId: string, userTwoId: string): Promise<Message[]>
⋮----
async getUserMessages(userId: string): Promise<Message[]>
⋮----
async createMessage(insertMessage: InsertMessage): Promise<Message>
⋮----
async markMessageAsRead(id: number): Promise<Message | undefined>
⋮----
// Notification operations
async getNotification(id: number): Promise<Notification | undefined>
⋮----
async getNotificationsByUserId(userId: string): Promise<Notification[]>
⋮----
async getUnreadNotificationsByUserId(userId: string): Promise<Notification[]>
⋮----
async createNotification(insertNotification: InsertNotification): Promise<Notification>
⋮----
async markNotificationAsRead(id: number): Promise<Notification | undefined>
⋮----
async markAllNotificationsAsRead(userId: string): Promise<void>
⋮----
// Reminder operations
// Pending booking operations
async getPendingBookingsOlderThan(minutes: number): Promise<Booking[]>
⋮----
async getRemindersToSend(reminderType: 'one_week' | 'one_day', currentDate: Date): Promise<Booking[]>
⋮----
// Find bookings that have reminder time before now and haven't been sent yet
</file>

<file path="backend/db.js">
// MongoDB connection URI
⋮----
// Create a MongoClient with a MongoClientOptions object
const client = new MongoClient(uri, {
⋮----
/**
 * Connect to MongoDB and store the connection
 */
async function connectToDatabase() {
⋮----
await client.connect();
console.log('Connected to MongoDB');
dbConnection = client.db('linxGolf');
⋮----
console.error('Error connecting to MongoDB:', error);
⋮----
/**
 * Get the database connection, connecting if not already connected
 */
async function getDb() {
⋮----
return await connectToDatabase();
⋮----
// Collections mapping
</file>

<file path="backend/db.ts">
import { Pool } from 'pg';
import { drizzle } from 'drizzle-orm/node-postgres';
⋮----
// Create connection pool for Supabase PostgreSQL
⋮----
// Supabase specific configuration
⋮----
// Connection pool settings
max: 20, // Maximum number of clients in the pool
idleTimeoutMillis: 30000, // Close idle clients after 30 seconds
connectionTimeoutMillis: 2000, // Return an error after 2 seconds if connection could not be established
⋮----
// Initialize Drizzle ORM with the connection pool and schema
⋮----
// Handle pool errors
⋮----
// Graceful shutdown
</file>

<file path="backend/express-app.js">
// Create Express app
const app = express();
⋮----
/**
 * Configure Express application with middleware
 */
async function configureApp() {
// Connect to MongoDB first
await connectToDatabase();
⋮----
// Set up session middleware
app.use(session({
⋮----
maxAge: 1000 * 60 * 60 * 24 * 7, // 1 week
⋮----
// Basic middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
⋮----
// Static files middleware
⋮----
app.use(express.static(path.join(__dirname, '../public')));
⋮----
// Authentication middleware - applies to all /api routes except auth-related ones
app.use('/api', (req, res, next) => {
// Skip authentication for these endpoints
⋮----
req.path.startsWith('/auth') ||
⋮----
return next();
⋮----
validateFirebaseToken(req, res, next);
</file>

<file path="backend/firebase-auth.js">
/**
 * Middleware to verify Firebase token and attach user to request
 */
const validateFirebaseToken = async (req, res, next) => {
⋮----
if (!authHeader || !authHeader.startsWith('Bearer ')) {
return res.status(401).json({ message: 'Unauthorized - No token provided' });
⋮----
const idToken = authHeader.split('Bearer ')[1];
⋮----
// Verify the token
const decodedToken = await admin.auth().verifyIdToken(idToken);
⋮----
// Get the user from our database based on Firebase ID
let user = await mongoStorage.getUserByFirebaseId(decodedToken.uid);
⋮----
// If no user exists in our db but is authenticated with Firebase, create the user
⋮----
// Get user details from Firebase
const firebaseUser = await admin.auth().getUser(decodedToken.uid);
⋮----
// Create user in our database
user = await mongoStorage.createUser({
⋮----
username: firebaseUser.displayName || firebaseUser.email.split('@')[0],
firstName: firebaseUser.displayName?.split(' ')[0] || null,
lastName: firebaseUser.displayName?.split(' ').slice(1).join(' ') || null,
⋮----
isHost: false, // By default, new users are not hosts
createdAt: new Date(),
updatedAt: new Date()
⋮----
next();
⋮----
console.error('Error validating Firebase token:', error);
return res.status(401).json({ message: 'Unauthorized - Invalid token' });
⋮----
/**
 * Middleware to check if a user is authenticated
 */
const isAuthenticated = (req, res, next) => {
⋮----
return next();
⋮----
res.status(401).json({ message: 'Unauthorized' });
⋮----
/**
 * Middleware to check if a user is a host
 */
const isHost = (req, res, next) => {
⋮----
res.status(403).json({ message: 'Forbidden - Host access required' });
</file>

<file path="backend/firebase.js">
// Initialize Firebase Admin with environment variables or service account
⋮----
// Check if we have service account credentials
⋮----
// Parse the service account JSON if it's provided as a string
const serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
⋮----
admin.initializeApp({
credential: admin.credential.cert(serviceAccount)
⋮----
// Otherwise initialize with application default credentials
⋮----
console.log('Firebase Admin initialized successfully');
⋮----
console.error('Error initializing Firebase Admin:', error);
⋮----
// Function to inject Firebase config into HTML template
function injectFirebaseConfig(html) {
⋮----
.replace(/{{FIREBASE_API_KEY}}/g, process.env.FIREBASE_API_KEY || '')
.replace(/{{FIREBASE_AUTH_DOMAIN}}/g, process.env.FIREBASE_AUTH_DOMAIN || '')
.replace(/{{FIREBASE_PROJECT_ID}}/g, process.env.FIREBASE_PROJECT_ID || '')
.replace(/{{FIREBASE_STORAGE_BUCKET}}/g, process.env.FIREBASE_STORAGE_BUCKET || '')
.replace(/{{FIREBASE_MESSAGING_SENDER_ID}}/g, process.env.FIREBASE_MESSAGING_SENDER_ID || '')
.replace(/{{FIREBASE_APP_ID}}/g, process.env.FIREBASE_APP_ID || '');
</file>

<file path="backend/index.ts">
import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";
import { startReminderService } from "./reminder-service";
import bookingService from "./booking-service";
⋮----
// Important: We don't apply JSON middleware to the webhook path
// so that it can receive the raw request body
⋮----
// Apply middleware conditionally - Skip for webhook paths
⋮----
// Skip body parsing for webhook endpoint
⋮----
// Skip body parsing for webhook endpoint
⋮----
// importantly only setup vite in development and after
// setting up all the other routes so the catch-all route
// doesn't interfere with the other routes
⋮----
// ALWAYS serve the app on port 3001
// this serves both the API and the client.
// It is the only port that is not firewalled.
⋮----
// Start the reminder service
⋮----
// Start the booking service (Timekit-like functionality)
</file>

<file path="backend/mongo-storage.js">
/**
 * MongoDB implementation of the storage interface
 */
class MongoStorage {
⋮----
this.sessionStore = MongoStore.create({
⋮----
ttl: 14 * 24 * 60 * 60, // 14 days
⋮----
// Helper method to get a collection
async getCollection(collectionName) {
const db = await getDb();
return db.collection(collectionName);
⋮----
// User operations
async getUser(id) {
const userCollection = await this.getCollection(collections.USERS);
const query = typeof id === 'string' ? { firebaseId: id } : { _id: new ObjectId(id) };
return userCollection.findOne(query);
⋮----
async getUserByUsername(username) {
⋮----
return userCollection.findOne({ username });
⋮----
async getUserByEmail(email) {
⋮----
return userCollection.findOne({ email });
⋮----
async getUserByFirebaseId(firebaseId) {
⋮----
return userCollection.findOne({ firebaseId });
⋮----
async createUser(userData) {
⋮----
const result = await userCollection.insertOne({
⋮----
createdAt: new Date(),
updatedAt: new Date()
⋮----
return this.getUser(result.insertedId);
⋮----
async updateUser(id, userData) {
⋮----
await userCollection.updateOne(query, { $set: updatedData });
return this.getUser(id);
⋮----
async updateUserStripeInfo(id, stripeInfo) {
⋮----
async upsertUser(upsertUser) {
// If firebase ID is provided, use that as the key
⋮----
const existingUser = await this.getUserByFirebaseId(upsertUser.firebaseId);
⋮----
return this.updateUser(existingUser._id, upsertUser);
⋮----
// Use email as fallback if provided
⋮----
const existingUser = await this.getUserByEmail(upsertUser.email);
⋮----
// Otherwise create new user
return this.createUser(upsertUser);
⋮----
// Club operations
async getClub(id) {
const clubCollection = await this.getCollection(collections.CLUBS);
return clubCollection.findOne({ _id: new ObjectId(id) });
⋮----
async getClubs() {
⋮----
return clubCollection.find().toArray();
⋮----
async createClub(clubData) {
⋮----
const result = await clubCollection.insertOne({
⋮----
createdAt: new Date()
⋮----
return this.getClub(result.insertedId);
⋮----
// UserClub operations
async getUserClubs(userId) {
const userClubCollection = await this.getCollection(collections.USER_CLUBS);
return userClubCollection.find({ userId: new ObjectId(userId) }).toArray();
⋮----
async addUserToClub(userClubData) {
⋮----
const result = await userClubCollection.insertOne({
userId: new ObjectId(userClubData.userId),
clubId: new ObjectId(userClubData.clubId),
memberSince: userClubData.memberSince || new Date()
⋮----
return userClubCollection.findOne({ _id: result.insertedId });
⋮----
// TeeTimeListing operations
async getTeeTimeListing(id) {
const teeTimeCollection = await this.getCollection(collections.TEE_TIME_LISTINGS);
return teeTimeCollection.findOne({ _id: new ObjectId(id) });
⋮----
async getTeeTimeListingsByHostId(hostId) {
⋮----
return teeTimeCollection.find({ hostId: new ObjectId(hostId) }).toArray();
⋮----
async getTeeTimeListingsByClubId(clubId) {
⋮----
return teeTimeCollection.find({ clubId: new ObjectId(clubId) }).toArray();
⋮----
async getAvailableTeeTimeListings() {
⋮----
return teeTimeCollection.find({
⋮----
date: { $gt: new Date() }
}).toArray();
⋮----
async createTeeTimeListing(teeTimeData) {
⋮----
const result = await teeTimeCollection.insertOne({
hostId: new ObjectId(teeTimeData.hostId),
clubId: new ObjectId(teeTimeData.clubId),
date: new Date(teeTimeData.date),
⋮----
return this.getTeeTimeListing(result.insertedId);
⋮----
async updateTeeTimeListing(id, teeTimeData) {
⋮----
await teeTimeCollection.updateOne(
{ _id: new ObjectId(id) },
⋮----
return this.getTeeTimeListing(id);
⋮----
// Booking operations
async getBooking(id) {
const bookingCollection = await this.getCollection(collections.BOOKINGS);
return bookingCollection.findOne({ _id: new ObjectId(id) });
⋮----
async getBookingsByGuestId(guestId) {
⋮----
return bookingCollection.find({ guestId: new ObjectId(guestId) }).toArray();
⋮----
async getBookingsByTeeTimeId(teeTimeId) {
⋮----
return bookingCollection.find({ teeTimeId: new ObjectId(teeTimeId) }).toArray();
⋮----
async createBooking(bookingData) {
⋮----
teeTimeId: new ObjectId(bookingData.teeTimeId),
guestId: new ObjectId(bookingData.guestId),
⋮----
const result = await bookingCollection.insertOne(newBooking);
return this.getBooking(result.insertedId);
⋮----
async updateBooking(id, bookingData) {
⋮----
await bookingCollection.updateOne(
⋮----
return this.getBooking(id);
⋮----
async updateBookingStatus(id, status) {
⋮----
updateData.completedAt = new Date();
⋮----
// Review operations
async getReview(id) {
const reviewCollection = await this.getCollection(collections.REVIEWS);
return reviewCollection.findOne({ _id: new ObjectId(id) });
⋮----
async getReviewsByTargetId(targetId, targetType) {
⋮----
return reviewCollection.find({
targetId: new ObjectId(targetId),
⋮----
async getReviewsByReviewerId(reviewerId) {
⋮----
return reviewCollection.find({ reviewerId: new ObjectId(reviewerId) }).toArray();
⋮----
async createReview(reviewData) {
⋮----
reviewerId: new ObjectId(reviewData.reviewerId),
targetId: new ObjectId(reviewData.targetId),
⋮----
bookingId: reviewData.bookingId ? new ObjectId(reviewData.bookingId) : null,
⋮----
const result = await reviewCollection.insertOne(newReview);
return this.getReview(result.insertedId);
⋮----
// Message operations
async getMessage(id) {
const messageCollection = await this.getCollection(collections.MESSAGES);
return messageCollection.findOne({ _id: new ObjectId(id) });
⋮----
async getMessagesByBookingId(bookingId) {
⋮----
return messageCollection.find(
{ bookingId: new ObjectId(bookingId) },
⋮----
).toArray();
⋮----
async getConversation(userOneId, userTwoId) {
⋮----
return messageCollection.find({
⋮----
{ senderId: new ObjectId(userOneId), receiverId: new ObjectId(userTwoId) },
{ senderId: new ObjectId(userTwoId), receiverId: new ObjectId(userOneId) }
⋮----
}, { sort: { createdAt: 1 } }).toArray();
⋮----
async getUserMessages(userId) {
⋮----
{ senderId: new ObjectId(userId) },
{ receiverId: new ObjectId(userId) }
⋮----
}, { sort: { createdAt: -1 } }).toArray();
⋮----
async createMessage(messageData) {
⋮----
senderId: new ObjectId(messageData.senderId),
receiverId: new ObjectId(messageData.receiverId),
bookingId: messageData.bookingId ? new ObjectId(messageData.bookingId) : null,
⋮----
const result = await messageCollection.insertOne(newMessage);
return this.getMessage(result.insertedId);
⋮----
async markMessageAsRead(id) {
⋮----
await messageCollection.updateOne(
⋮----
return this.getMessage(id);
⋮----
// Notification operations
async getNotification(id) {
const notificationCollection = await this.getCollection(collections.NOTIFICATIONS);
return notificationCollection.findOne({ _id: new ObjectId(id) });
⋮----
async getNotificationsByUserId(userId) {
⋮----
return notificationCollection.find(
{ userId: new ObjectId(userId) },
⋮----
async getUnreadNotificationsByUserId(userId) {
⋮----
{ userId: new ObjectId(userId), isRead: false },
⋮----
async createNotification(notificationData) {
⋮----
userId: new ObjectId(notificationData.userId),
⋮----
relatedId: new ObjectId(notificationData.relatedId),
⋮----
const result = await notificationCollection.insertOne(newNotification);
return this.getNotification(result.insertedId);
⋮----
async markNotificationAsRead(id) {
⋮----
await notificationCollection.updateOne(
⋮----
return this.getNotification(id);
⋮----
async markAllNotificationsAsRead(userId) {
⋮----
await notificationCollection.updateMany(
⋮----
// Reminder operations
async getRemindersToSend(reminderType, currentDate) {
⋮----
// Get bookings that need reminders
const bookings = await bookingCollection.find({
⋮----
// For each booking, get the tee time and check if it's within the reminder window
⋮----
const now = currentDate || new Date();
⋮----
const teeTime = await teeTimeCollection.findOne({ _id: booking.teeTimeId });
⋮----
// Calculate when the reminder should be sent
const teeTimeDate = new Date(teeTime.date);
const reminderDate = new Date(teeTimeDate);
⋮----
reminderDate.setDate(reminderDate.getDate() - 7);
⋮----
reminderDate.setDate(reminderDate.getDate() - 1);
⋮----
// If we've passed the reminder date and reminder hasn't been sent
⋮----
result.push(booking);
⋮----
module.exports = new MongoStorage();
</file>

<file path="backend/new-express-app.js">
// Create Express app
const app = express();
⋮----
/**
 * Configure Express application with middleware
 */
async function configureApp() {
// Connect to MongoDB first
await connectToDatabase();
⋮----
// Set up session middleware
app.use(session({
⋮----
maxAge: 1000 * 60 * 60 * 24 * 7, // 1 week
⋮----
// Basic middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
⋮----
// Stripe webhook needs raw body
app.use('/api/webhook', express.raw({ type: 'application/json' }));
⋮----
// Authentication middleware - applies to all /api routes except auth-related ones
app.use('/api', (req, res, next) => {
// Skip authentication for these endpoints
⋮----
req.path.startsWith('/auth') ||
⋮----
return next();
⋮----
validateFirebaseToken(req, res, next);
⋮----
// Serve static files from the public directory
app.use(express.static(path.join(__dirname, '../public')));
⋮----
// Special handling for HTML files to inject Firebase config
app.get('*', async (req, res, next) => {
// If this is an API request or already handled, skip
if (req.path.startsWith('/api') || req.path.includes('.')) {
⋮----
// Read the index.html file
const indexPath = path.join(__dirname, '../public/index.html');
const html = await fs.readFile(indexPath, 'utf8');
⋮----
// Inject Firebase configuration
const injectedHtml = injectFirebaseConfig(html);
⋮----
// Send the HTML with the correct content type
res.setHeader('Content-Type', 'text/html');
res.send(injectedHtml);
⋮----
console.error('Error serving HTML:', error);
next(error);
⋮----
// Error handling middleware
app.use((err, req, res, next) => {
console.error('Express error:', err);
⋮----
res.status(err.status || 500).json({
</file>

<file path="backend/new-index.js">
/**
 * Initialize and start the server
 */
async function startServer() {
⋮----
// Configure Express application
const app = await configureApp();
⋮----
// Create HTTP server
const httpServer = createServer(app);
⋮----
// Set up WebSocket server
const wss = new WebSocketServer({ server: httpServer, path: '/ws' });
⋮----
// WebSocket connection handler
wss.on('connection', (ws) => {
console.log('WebSocket client connected');
⋮----
ws.on('message', (message) => {
console.log('Received message:', message);
⋮----
// Here we would process the message and possibly broadcast to other clients
⋮----
const data = JSON.parse(message);
⋮----
// Broadcast to all connected clients if needed
wss.clients.forEach((client) => {
⋮----
client.send(JSON.stringify({
⋮----
console.error('Error processing message:', error);
⋮----
ws.on('close', () => {
console.log('WebSocket client disconnected');
⋮----
// Send initial connection acknowledgment
ws.send(JSON.stringify({ type: 'connection', status: 'connected' }));
⋮----
// Register API routes
await registerRoutes(app);
⋮----
// Start the reminder service
const reminderService = startReminderService();
⋮----
// Start listening on the configured port
⋮----
httpServer.listen(PORT, '0.0.0.0', () => {
console.log(`Server listening on port ${PORT}`);
⋮----
// Handle graceful shutdown
const shutdown = async () => {
console.log('Shutting down server...');
⋮----
// Stop the reminder service if it's running
⋮----
clearInterval(reminderService);
⋮----
// Close the WebSocket server
wss.close(() => {
console.log('WebSocket server closed');
⋮----
// Close the HTTP server
httpServer.close(() => {
console.log('HTTP server closed');
process.exit(0);
⋮----
// If everything doesn't close properly within 5 seconds, force exit
setTimeout(() => {
console.error('Could not close connections in time, forcefully shutting down');
process.exit(1);
⋮----
// Listen for shutdown signals
process.on('SIGTERM', shutdown);
process.on('SIGINT', shutdown);
⋮----
console.error('Failed to start server:', error);
⋮----
// Start the server if this file is run directly
⋮----
startServer();
</file>

<file path="backend/new-main.js">
// Entry point for the server with MongoDB and Firebase
⋮----
// Start the server
⋮----
// This function call configures the Express app,
// registers the routes, sets up the WebSocket server,
// starts the reminder service, and begins listening for requests
await startServer();
⋮----
console.log('Server started successfully');
⋮----
console.error('Failed to start server:', error);
process.exit(1);
</file>

<file path="backend/new-reminder-service.js">
/**
 * Check for reminders that need to be sent
 * This function should be run periodically (e.g., every hour)
 */
async function checkReminders() {
console.log('Checking for reminders to send...');
⋮----
const now = new Date();
⋮----
// Check for one week reminders
await checkOneWeekReminders(now);
⋮----
// Check for one day reminders
await checkOneDayReminders(now);
⋮----
console.log('Reminder check completed');
⋮----
console.error('Error checking reminders:', error);
⋮----
/**
 * Check for one week reminders that need to be sent
 */
async function checkOneWeekReminders(now) {
⋮----
const bookings = await storage.getRemindersToSend('one_week', now);
⋮----
console.log('No one week reminders to send');
⋮----
console.log(`Sending ${bookings.length} one week reminders`);
⋮----
// Get related data
const teeTime = await storage.getTeeTimeListing(booking.teeTimeId);
const guest = await storage.getUser(booking.guestId);
const club = teeTime ? await storage.getClub(teeTime.clubId) : null;
⋮----
console.error(`Missing data for booking ${booking._id}`);
⋮----
// Send email reminder
await sendReminderEmail(guest, booking, teeTime, club, 'one_week');
⋮----
// Mark reminder as sent
await storage.updateBooking(booking._id, { reminderOneWeekSent: true });
⋮----
// Create in-app notification
await storage.createNotification({
⋮----
console.log(`Sent one week reminder for booking ${booking._id}`);
⋮----
console.error(`Error sending reminder for booking ${booking._id}:`, error);
⋮----
console.error('Error checking one week reminders:', error);
⋮----
/**
 * Check for one day reminders that need to be sent
 */
async function checkOneDayReminders(now) {
⋮----
const bookings = await storage.getRemindersToSend('one_day', now);
⋮----
console.log('No one day reminders to send');
⋮----
console.log(`Sending ${bookings.length} one day reminders`);
⋮----
await sendReminderEmail(guest, booking, teeTime, club, 'one_day');
⋮----
await storage.updateBooking(booking._id, { reminderOneDaySent: true });
⋮----
console.log(`Sent one day reminder for booking ${booking._id}`);
⋮----
console.error('Error checking one day reminders:', error);
⋮----
/**
 * Start reminder service
 * This function will check for reminders every hour
 */
function startReminderService() {
console.log('Starting reminder service...');
⋮----
// Check immediately on startup
checkReminders();
⋮----
// Then check every hour
return setInterval(checkReminders, 60 * 60 * 1000);
</file>

<file path="backend/new-routes.js">
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || 'sk_test_dummy', {
⋮----
/**
 * Register all API routes
 */
async function registerRoutes(app) {
// Firebase auth routes
const authRoutes = express.Router();
⋮----
// Get current user info
authRoutes.get('/me', isAuthenticated, (req, res) => {
res.json(req.user);
⋮----
// Update Firebase user profile
authRoutes.patch('/profile', isAuthenticated, async (req, res) => {
⋮----
Object.keys(req.body).forEach(key => {
if (allowedFields.includes(key)) {
⋮----
const updatedUser = await storage.updateUser(req.user._id, updateData);
res.json(updatedUser);
⋮----
console.error('Error updating profile:', error);
res.status(500).json({ message: 'Failed to update profile' });
⋮----
app.use('/api/auth', authRoutes);
⋮----
// User routes
const userRoutes = express.Router();
⋮----
userRoutes.get('/:id', async (req, res) => {
⋮----
const user = await storage.getUser(req.params.id);
⋮----
return res.status(404).json({ message: 'User not found' });
⋮----
// Don't return sensitive information
⋮----
res.json(user);
⋮----
console.error('Error fetching user:', error);
res.status(500).json({ message: 'Failed to fetch user' });
⋮----
app.use('/api/users', userRoutes);
⋮----
// Club routes
const clubRoutes = express.Router();
⋮----
clubRoutes.get('/', async (req, res) => {
⋮----
const clubs = await storage.getClubs();
res.json(clubs);
⋮----
console.error('Error fetching clubs:', error);
res.status(500).json({ message: 'Failed to fetch clubs' });
⋮----
clubRoutes.get('/:id', async (req, res) => {
⋮----
const club = await storage.getClub(req.params.id);
⋮----
return res.status(404).json({ message: 'Club not found' });
⋮----
res.json(club);
⋮----
console.error('Error fetching club:', error);
res.status(500).json({ message: 'Failed to fetch club' });
⋮----
clubRoutes.post('/', isAuthenticated, async (req, res) => {
⋮----
const club = await storage.createClub(req.body);
res.status(201).json(club);
⋮----
console.error('Error creating club:', error);
res.status(500).json({ message: 'Failed to create club' });
⋮----
app.use('/api/clubs', clubRoutes);
⋮----
// User Club routes
const userClubRoutes = express.Router();
⋮----
userClubRoutes.get('/:userId/clubs', async (req, res) => {
⋮----
const userClubs = await storage.getUserClubs(req.params.userId);
⋮----
// Get full club details for each club membership
const clubDetails = await Promise.all(
userClubs.map(async (userClub) => {
const club = await storage.getClub(userClub.clubId);
⋮----
res.json(clubDetails);
⋮----
console.error('Error fetching user clubs:', error);
res.status(500).json({ message: 'Failed to fetch user clubs' });
⋮----
userClubRoutes.post('/', isAuthenticated, async (req, res) => {
⋮----
// Ensure the user is adding themselves to a club
if (req.user._id.toString() !== req.body.userId) {
return res.status(403).json({ message: 'You can only add yourself to a club' });
⋮----
const userClub = await storage.addUserToClub(req.body);
res.status(201).json(userClub);
⋮----
console.error('Error adding user to club:', error);
res.status(500).json({ message: 'Failed to add user to club' });
⋮----
app.use('/api/user-clubs', userClubRoutes);
⋮----
// Tee Time Listing routes
const teeTimeRoutes = express.Router();
⋮----
teeTimeRoutes.get('/', async (req, res) => {
⋮----
const teeTimeListings = await storage.getAvailableTeeTimeListings();
⋮----
// Get detailed information for each listing
let detailedListings = await Promise.all(
teeTimeListings.map(async (listing) => {
const host = await storage.getUser(listing.hostId);
const club = await storage.getClub(listing.clubId);
const hostReviews = await storage.getReviewsByTargetId(listing.hostId, 'host');
⋮----
// Calculate average rating
⋮----
? hostReviews.reduce((sum, review) => sum + review.rating, 0) / hostReviews.length
⋮----
relevanceScore: 0 // Default relevance score
⋮----
// Apply search relevance scoring based on query parameters
⋮----
detailedListings = applySearchRelevanceScoring(detailedListings, {
⋮----
players: players ? parseInt(players) : undefined
⋮----
res.json(detailedListings);
⋮----
console.error('Error fetching tee time listings:', error);
res.status(500).json({ message: 'Failed to fetch tee time listings' });
⋮----
teeTimeRoutes.get('/:id', async (req, res) => {
⋮----
const teeTime = await storage.getTeeTimeListing(req.params.id);
⋮----
return res.status(404).json({ message: 'Tee time listing not found' });
⋮----
// Get detailed information
const host = await storage.getUser(teeTime.hostId);
const club = await storage.getClub(teeTime.clubId);
const hostReviews = await storage.getReviewsByTargetId(teeTime.hostId, 'host');
⋮----
res.json({
⋮----
console.error('Error fetching tee time listing:', error);
res.status(500).json({ message: 'Failed to fetch tee time listing' });
⋮----
teeTimeRoutes.post('/', isAuthenticated, isHost, async (req, res) => {
⋮----
// Ensure the user is creating a tee time as themselves
⋮----
const teeTime = await storage.createTeeTimeListing(teeTimeData);
res.status(201).json(teeTime);
⋮----
console.error('Error creating tee time listing:', error);
res.status(500).json({ message: 'Failed to create tee time listing' });
⋮----
teeTimeRoutes.patch('/:id', isAuthenticated, isHost, async (req, res) => {
⋮----
// Ensure the user is updating their own tee time
if (!teeTime || teeTime.hostId.toString() !== req.user._id.toString()) {
return res.status(403).json({ message: 'You can only update your own tee time listings' });
⋮----
const updatedTeeTime = await storage.updateTeeTimeListing(req.params.id, req.body);
res.json(updatedTeeTime);
⋮----
console.error('Error updating tee time listing:', error);
res.status(500).json({ message: 'Failed to update tee time listing' });
⋮----
app.use('/api/tee-times', teeTimeRoutes);
⋮----
// Booking routes
const bookingRoutes = express.Router();
⋮----
bookingRoutes.get('/guest/:guestId', isAuthenticated, async (req, res) => {
⋮----
// Ensure the user is viewing their own bookings
if (req.user._id.toString() !== req.params.guestId) {
return res.status(403).json({ message: 'You can only view your own bookings' });
⋮----
const bookings = await storage.getBookingsByGuestId(req.params.guestId);
⋮----
// Get detailed information for each booking
const detailedBookings = await Promise.all(
bookings.map(async (booking) => {
const teeTime = await storage.getTeeTimeListing(booking.teeTimeId);
const club = teeTime ? await storage.getClub(teeTime.clubId) : null;
const host = teeTime ? await storage.getUser(teeTime.hostId) : null;
⋮----
res.json(detailedBookings);
⋮----
console.error('Error fetching bookings:', error);
res.status(500).json({ message: 'Failed to fetch bookings' });
⋮----
bookingRoutes.get('/tee-time/:teeTimeId', isAuthenticated, async (req, res) => {
⋮----
const teeTime = await storage.getTeeTimeListing(req.params.teeTimeId);
⋮----
// Ensure the user is the host of this tee time
⋮----
return res.status(403).json({ message: 'You can only view bookings for your own tee times' });
⋮----
const bookings = await storage.getBookingsByTeeTimeId(req.params.teeTimeId);
⋮----
// Get guest information for each booking
⋮----
const guest = await storage.getUser(booking.guestId);
⋮----
console.error('Error fetching bookings for tee time:', error);
res.status(500).json({ message: 'Failed to fetch bookings for tee time' });
⋮----
bookingRoutes.post('/', isAuthenticated, async (req, res) => {
⋮----
// Ensure the user is booking as themselves
⋮----
// Get the tee time to confirm it's available
const teeTime = await storage.getTeeTimeListing(bookingData.teeTimeId);
⋮----
return res.status(400).json({ message: 'This tee time is not available for booking' });
⋮----
// Create the booking
const booking = await storage.createBooking(bookingData);
⋮----
// Create a Stripe PaymentIntent
const paymentIntent = await stripe.paymentIntents.create({
amount: Math.round(bookingData.totalPrice * 100), // Convert to cents
⋮----
bookingId: booking._id.toString(),
teeTimeId: teeTime._id.toString()
⋮----
// Update the booking with the PaymentIntent ID
await storage.updateBooking(booking._id, {
⋮----
// Return the booking and client secret
res.status(201).json({
⋮----
console.error('Error creating booking:', error);
res.status(500).json({ message: 'Failed to create booking' });
⋮----
bookingRoutes.patch('/:id/status', isAuthenticated, async (req, res) => {
⋮----
return res.status(400).json({ message: 'Status is required' });
⋮----
// Get the booking
const booking = await storage.getBooking(req.params.id);
⋮----
return res.status(404).json({ message: 'Booking not found' });
⋮----
// Get the tee time to check host
⋮----
// Ensure the user is either the host or the guest
const isHost = teeTime && teeTime.hostId.toString() === req.user._id.toString();
const isGuest = booking.guestId.toString() === req.user._id.toString();
⋮----
return res.status(403).json({ message: 'You are not authorized to update this booking' });
⋮----
// Different status updates have different requirements
⋮----
return res.status(403).json({ message: 'Only the host can confirm bookings' });
⋮----
return res.status(403).json({ message: 'Only the guest can cancel bookings' });
⋮----
const updatedBooking = await storage.updateBookingStatus(req.params.id, status);
⋮----
// If the booking is cancelled, update the tee time status back to available
⋮----
await storage.updateTeeTimeListing(booking.teeTimeId, { status: 'available' });
⋮----
res.json(updatedBooking);
⋮----
console.error('Error updating booking status:', error);
res.status(500).json({ message: 'Failed to update booking status' });
⋮----
app.use('/api/bookings', bookingRoutes);
⋮----
// Stripe webhook handler
app.post('/webhook', express.raw({ type: 'application/json' }), async (req, res) => {
⋮----
event = stripe.webhooks.constructEvent(
⋮----
console.error(`Webhook signature verification failed: ${err.message}`);
return res.status(400).send(`Webhook Error: ${err.message}`);
⋮----
// Handle the event
⋮----
// Update booking status
⋮----
// Update booking status to confirmed
await storage.updateBookingStatus(bookingId, 'confirmed');
⋮----
// Update tee time status to booked
await storage.updateTeeTimeListing(teeTimeId, { status: 'booked' });
⋮----
console.error('Error processing payment success webhook:', error);
⋮----
// Return a response to acknowledge receipt of the event
res.json({ received: true });
⋮----
// Health check route
app.get('/api/health', (req, res) => {
res.json({ status: 'ok' });
⋮----
/**
 * Helper function to score tee time listings based on search criteria
 */
function applySearchRelevanceScoring(listings, criteria) {
⋮----
const scoredListings = listings.map(listing => {
⋮----
// Location relevance (highest priority - up to 20 points)
⋮----
const searchTerms = location.toLowerCase().split(/[ ,]+/); // Split by space or comma
const clubLocation = listing.club?.location?.toLowerCase() || '';
const clubName = listing.club?.name?.toLowerCase() || '';
⋮----
searchTerms.forEach(term => {
// Exact match in location gives highest score
if (clubLocation.includes(term)) {
⋮----
// Bonus points for exact city/state match
if (clubLocation.split(',').some(part => part.trim() === term.trim())) {
⋮----
// Match in club name
if (clubName.includes(term)) {
⋮----
// Date relevance (medium priority - up to 8 points)
⋮----
const searchDate = new Date(date);
const listingDate = new Date(listing.date);
⋮----
// Exact date match
⋮----
searchDate.getFullYear() === listingDate.getFullYear() &&
searchDate.getMonth() === listingDate.getMonth() &&
searchDate.getDate() === listingDate.getDate()
⋮----
// Same week (within 3 days)
else if (Math.abs(searchDate.getTime() - listingDate.getTime()) < 3 * 24 * 60 * 60 * 1000) {
⋮----
// Within two weeks
else if (Math.abs(searchDate.getTime() - listingDate.getTime()) < 14 * 24 * 60 * 60 * 1000) {
⋮----
// Invalid date format, ignore
⋮----
// Players relevance (lower priority - up to 5 points)
⋮----
// Exact match (e.g., requested 4, available 4)
⋮----
// Has more spots than needed but not too many
⋮----
// Has spots, but many more than needed
⋮----
// Sort by relevance score (highest first)
return scoredListings.sort((a, b) => b.relevanceScore - a.relevanceScore);
</file>

<file path="backend/reminder-service.ts">
import { storage } from './storage';
import { sendOneWeekReminder, sendOneDayReminder } from './notifications/index';
⋮----
/**
 * Check for reminders that need to be sent
 * This function should be run periodically (e.g., every hour)
 */
export async function checkReminders(): Promise<void>
⋮----
// Get current date
⋮----
// Check for one week reminders
⋮----
// Check for one day reminders
⋮----
/**
 * Check for one week reminders that need to be sent
 */
async function checkOneWeekReminders(now: Date): Promise<void>
⋮----
// Get bookings with one week reminder due and not yet sent
⋮----
// Send reminders
⋮----
/**
 * Check for one day reminders that need to be sent
 */
async function checkOneDayReminders(now: Date): Promise<void>
⋮----
// Get bookings with one day reminder due and not yet sent
⋮----
// Send reminders
⋮----
/**
 * Start reminder service
 * This function will check for reminders every hour
 */
export function startReminderService(): NodeJS.Timer
⋮----
// Run immediately
⋮----
// Schedule to run every hour
⋮----
}, 60 * 60 * 1000); // 1 hour
</file>

<file path="backend/routes.ts">
import type { Express, Request, Response, NextFunction } from "express";
import express from "express";
import { createServer, type Server } from "http";
import { WebSocketServer, WebSocket } from "ws";
import { storage } from "./storage";
import Stripe from "stripe";
import { z } from "zod";
import bookingService from "./booking-service";
import { 
  insertUserSchema, 
  insertClubSchema, 
  insertUserClubSchema, 
  insertTeeTimeListingSchema, 
  insertBookingSchema, 
  insertReviewSchema, 
  insertMessageSchema,
  insertNotificationSchema
} from "@shared/schema";
import notificationsRoutes from './routes/notifications';
import { setupAuth, isAuthenticated, isHost, hashPassword } from "./auth";
⋮----
// Check for required Stripe API keys
⋮----
// Don't use a placeholder for production as it will cause API errors
⋮----
// Verify Stripe webhook secret is configured
⋮----
// Initialize Stripe with the secret key
⋮----
// Active WebSocket connections
⋮----
// Keep track of processed webhook events to avoid duplicates
⋮----
export async function registerRoutes(app: Express): Promise<Server>
⋮----
// Set up authentication with our simplified approach
⋮----
// DEVELOPMENT ONLY: Test route to create or reset test user
⋮----
// Create a test user if one doesn't exist
⋮----
password: 'temporary', // Will be overwritten below
⋮----
// Hash "password123" for the test user
⋮----
// Update the test user's password
⋮----
// Register all routes that use auth
⋮----
// User routes
⋮----
// Set cache control headers to prevent caching for user profile data
⋮----
// Log for debugging
⋮----
// Remove password from response
⋮----
// Make sure users can only update their own profile
⋮----
// Don't allow changing email or password this way
⋮----
// Add a timestamp to force cache refresh in browser
⋮----
// Remove password from response
⋮----
// Set cache control headers to prevent caching
⋮----
// Club routes
⋮----
// User Club routes
⋮----
// Get full club details
⋮----
// Ensure the user is adding themselves to a club
⋮----
// Tee Time Listing routes
⋮----
// Get detailed information
⋮----
// Calculate average rating
⋮----
relevanceScore: 0 // Default relevance score
⋮----
// Apply explicit filters first (before ranking)
⋮----
startDate.setHours(0, 0, 0, 0); // Start of day
⋮----
// If endDate is provided, filter by date range
⋮----
endDateObj.setHours(23, 59, 59, 999); // End of day
⋮----
// If it's a Saturday (This Weekend filter), get Saturday and Sunday
else if (startDate.getDay() === 6) { // 6 is Saturday
⋮----
// Get the next day (Sunday)
⋮----
sunday.setHours(23, 59, 59, 999); // End of day
⋮----
// For regular date filters, find exact day match
⋮----
// Invalid date format, ignore filter
⋮----
// Price filters have been removed as requested
⋮----
// Apply players filter
⋮----
// Apply distance filter if both location and distance are provided
⋮----
// For each listing, calculate the approximate distance from the search location
// In a real implementation, this would use a geocoding service to find exact coordinates
// For now, we'll implement a simple check based on location string matching
⋮----
// If the listing's club has a location that exactly matches the search, it's 0 miles away
⋮----
// If the listing's club location contains the search location or vice versa, assume it's within the distance
// This is a simplification - in a real app you'd use latitude/longitude coordinates with the haversine formula
⋮----
// Assume it's within the specified distance
⋮----
// If locations share a city or state, assume they're within larger distances only
⋮----
// If they share a city/state, assume they're within 50 miles
⋮----
// For larger search radii, include some results from different areas too
⋮----
// Apply relevance scoring for sorting results
⋮----
// Location relevance (highest priority - up to 20 points)
⋮----
const searchTerms = location.toLowerCase().split(/[ ,]+/); // Split by space or comma
⋮----
// Exact match in location gives highest score
⋮----
// Bonus points for exact city/state match
⋮----
// Match in club name
⋮----
// Sort by relevance score (highest first)
⋮----
// Get detailed information
⋮----
// Calculate average rating
⋮----
// Get detailed information
⋮----
// First make sure the date is properly formatted as a Date object
⋮----
// Check if the user is creating a tee time for themselves
⋮----
// Check if tee time exists
⋮----
// Check if the user owns this tee time
⋮----
// Booking routes
⋮----
// Only the guest or the host of the tee time can view the booking
⋮----
// Get detailed information
⋮----
// PATCH endpoint to update a booking - supports the new payment/confirmation flow
⋮----
// Only the guest or host can update the booking
⋮----
// Validate the request body
⋮----
// If attempting to confirm the booking
⋮----
// Try to use booking service for confirmation if payment intent ID is provided
⋮----
// Fall through to manual update below
⋮----
// Manual confirmation fallback
⋮----
// Update booking status
⋮----
// Also update the payment intent ID if provided
⋮----
// Update tee time status
⋮----
// Send confirmation notification
⋮----
// For other updates, just update the booking
⋮----
// Users can only view their own bookings
⋮----
// Get detailed information
⋮----
// Hosts can only view bookings for their own tee times
⋮----
// Get all tee times for host
⋮----
// Get bookings for each tee time
⋮----
// Use our updated schema with optional fields
⋮----
// Validate with the updated schema
⋮----
// Check if user is booking for themselves
⋮----
// Check if tee time exists
⋮----
// Check if there are any pending bookings for this tee time
⋮----
// Explicitly check tee time status - better error messaging
⋮----
// First create a pending booking
⋮----
// Then immediately confirm it with the payment ID
⋮----
// Use booking service to create a pending booking (legacy flow)
// This handles setting tee time status to pending and creating the booking record
⋮----
// Send booking notifications
⋮----
// Import here to avoid circular dependencies
⋮----
// Don't fail the request just because notification failed
⋮----
// Check if booking exists
⋮----
// Check if user is the guest or the host
⋮----
// Use booking service for status transitions when applicable
⋮----
// Use booking service to handle cancellation properly
⋮----
// Fall back to manual update
⋮----
// Also update tee time status manually as fallback
⋮----
// Use booking service to handle confirmation
⋮----
// Fall back to manual update
⋮----
// For other status changes, just use the regular update
⋮----
// If booking is confirmed, schedule reminder notifications
⋮----
// Import here to avoid circular dependencies
⋮----
// Don't fail the request just because reminder scheduling failed
⋮----
// Trigger notifications
⋮----
// Don't fail the request just because notification failed
⋮----
// Review routes
⋮----
// Get reviewer details
⋮----
// Check if the user is creating a review themselves
⋮----
// Check if booking exists and is completed if a booking ID is provided
⋮----
// Verify user was part of this booking
⋮----
// Message routes
⋮----
// Check if booking exists
⋮----
// Check if user is part of the booking
⋮----
// Check if the other user exists
⋮----
// API endpoint to get all conversations for the authenticated user
⋮----
// Get all messages sent or received by this user
⋮----
// Get unique conversation partners
⋮----
// Build conversation summaries
⋮----
// Get the last message in this conversation
⋮----
// Count unread messages
⋮----
// Filter out null values and sort by last message time
⋮----
// Check if the user is sending a message as themselves
⋮----
// If booking ID is provided, verify user is part of the booking
⋮----
// Send message to recipient via WebSocket if they're connected
⋮----
// Check if message exists
⋮----
// Only the recipient can mark a message as read
⋮----
// Stripe payment routes
// New endpoint - creates payment intent without requiring a booking first
⋮----
// Get tee time details to validate
⋮----
// Check if tee time is available
⋮----
// Get club info for the description
⋮----
// Create payment intent with ONLY card payment method
⋮----
amount: Math.round(amount * 100), // Convert to cents
⋮----
payment_method_types: ['card'], // Restrict to cards only
⋮----
// Ensure only card payments are allowed
⋮----
// Disallow any automatic payment method selection
⋮----
// Manual booking confirmation endpoint - for emergency booking fixes when payment succeeds but confirmation fails
⋮----
// Get the booking to make sure it belongs to the user
⋮----
// If booking is already confirmed, just return it
⋮----
// Check tee time status
⋮----
// Check if tee time is already booked by someone else
⋮----
// Check if this booking was already confirmed but status mismatch occurred
⋮----
// Allow a wider range of confirmable states for manual confirmation
⋮----
// If the booking has a payment intent ID, check its status with Stripe first
⋮----
// If payment is successful or can be captured, proceed with confirmation
⋮----
// Fall back to manual update if booking service fails
⋮----
// Also update the tee time to booked status
⋮----
// If payment requires confirmation, try to confirm it first
⋮----
// If confirmation was successful, proceed with booking confirmation
⋮----
// For other payment states, we'll fall back to manual confirmation below
⋮----
// If we haven't confirmed the booking yet (due to no payment ID or payment not in correct state),
// perform a manual confirmation
⋮----
// Generate a mock payment ID if none exists
⋮----
// Try to use booking service first
⋮----
// Direct update as fallback
⋮----
// Also update the tee time to booked status
⋮----
// Send confirmation notification
⋮----
// Return detailed response
⋮----
// Get booking details
⋮----
// Ensure user is the one making the booking
⋮----
// Get tee time details
⋮----
// Calculate amount (ensure we have a valid number)
const totalPrice = booking.totalPrice || teeTime.price || 100; // Fallback to tee time price or 100
const amount = Math.round(totalPrice * 100); // convert to cents
⋮----
// Check if Stripe API key is properly configured
⋮----
// Generate a fake client secret for testing
⋮----
// Update booking with payment intent ID but don't confirm yet
⋮----
// Don't update tee time status until mock payment is "confirmed"
// (this will happen when user returns to the site after payment)
⋮----
// Return mock client secret
⋮----
// If we reach here, we have a valid API key
// Create a real payment intent
⋮----
payment_method_types: ['card'], // Restrict to cards only
⋮----
// Ensure only card payments are allowed
⋮----
// Disallow any automatic payment method selection
⋮----
// Update booking with payment intent ID
⋮----
// Get booking details
⋮----
// Get tee time details
⋮----
// Ensure user is the host
⋮----
// Check if payment intent exists
⋮----
// Check if booking is completed and 24 hours have passed
⋮----
// Capture payment
⋮----
// Notify host of payment
⋮----
// Import here to avoid circular dependencies
⋮----
// Don't fail the request just because notification failed
⋮----
// Account for Stripe Connect
⋮----
// Create Stripe Connect account
⋮----
// Update user with connect account ID
⋮----
// Create account link for onboarding
⋮----
// Notifications routes
⋮----
// Stripe webhook handler for automated payment processing
⋮----
// Return a 200 response immediately to acknowledge receipt
// This prevents Stripe from retrying the webhook due to long processing time
// We'll process the event asynchronously
const sendAcknowledgment = () =>
⋮----
// Log headers for debugging without revealing secrets
⋮----
// Log body type and size for debugging
⋮----
// Send acknowledgment immediately after verification
⋮----
sendAcknowledgment(); // Still send 200 to prevent retries
⋮----
// Handle specific events
⋮----
// Implement idempotency check using the global set
// In production, you'd want to store this in the database for persistence across restarts
⋮----
return; // Response already sent via sendAcknowledgment
⋮----
// Mark this event as processed
⋮----
// Extract metadata from payment intent
⋮----
const eventObject = event.data.object as any; // Cast to any to handle different event types
⋮----
// First check if we can find bookings directly by payment intent ID
⋮----
// Use the first matching booking (typically there should be only one)
⋮----
// Load related data
⋮----
// If we didn't find a booking by payment intent, check metadata
⋮----
// Check if this is from an existing booking
⋮----
// Check if this is from a direct payment (new flow)
⋮----
// Fetch the club data to have complete information
⋮----
// A payment intent was created, log it but don't take action yet
⋮----
// Payment succeeded
⋮----
// Verify payment intent status before proceeding
⋮----
return; // We already sent acknowledgment
⋮----
// Ensure we have metadata from the payment intent
⋮----
return; // We already sent acknowledgment
⋮----
// Case 1: We have an existing booking (legacy flow)
⋮----
// Use booking service to confirm the booking
// This handles updating both the booking status and tee time status
⋮----
// Fall back to manual updates if booking service fails
⋮----
// Update tee time status to booked if teeTime exists
⋮----
// Case 2: We have a direct payment without a booking yet (new flow)
⋮----
// Verify tee time is still available
⋮----
// Calculate total price based on tee time price and number of players
⋮----
// Create booking record using validated schema
⋮----
status: 'confirmed', // Directly create as confirmed since payment succeeded
⋮----
// Create the booking with comprehensive error handling
⋮----
// Update tee time status to booked
⋮----
// Continue with the booking since payment was successful
// We don't want to roll back the booking at this point
⋮----
// Update bookingId for notifications
⋮----
// Send confirmation notifications
⋮----
// Load notifications module and send confirmation notification
⋮----
// Non-critical error, log but continue
⋮----
// Don't return an error response here as the booking is already successfully created
// This is a non-critical background task
⋮----
// Payment failed (card declined, etc.)
⋮----
// Extract failure reason if available
⋮----
// Update booking status to payment_failed
⋮----
// Restore tee time back to available if it exists
⋮----
// Continue despite this error
⋮----
// Send notification about payment failure
⋮----
// Non-critical error, continue
⋮----
// We should still acknowledge receipt of the webhook event
⋮----
// Payment was canceled
⋮----
// Extract cancellation reason if available
⋮----
// Use booking service to cancel the booking
// This handles updating both the booking status and tee time status
⋮----
// Fall back to manual updates if booking service fails
⋮----
// Also manually update tee time status if needed
⋮----
// At this point we've tried everything, just continue to acknowledge the webhook
⋮----
// Send notification about cancellation - separate try/catch block
⋮----
// Non-critical error, continue
⋮----
// Funds have been captured (after the 24-hour escrow period)
⋮----
// Additional charge details for clarity
⋮----
// Update booking status to reflect payment completed to host
⋮----
// Continue despite this error to try notification
⋮----
// This is when the host actually receives the payment - send notification
⋮----
// Check if the specialized host payment notification function exists
⋮----
// Fallback to generic status change notification
⋮----
// Non-critical error, continue
⋮----
// Payment was refunded
⋮----
// Extract refund reason if available
⋮----
// Continue despite this error to try notification
⋮----
// Send notification in a separate try/catch block
⋮----
// Non-critical error, continue
⋮----
// Log but ignore other event types
⋮----
// Send a more detailed successful response with debugging info
⋮----
// Add metadata for debugging specific to each event type
⋮----
// Add event-specific metadata for debugging
⋮----
// Log response for debugging
⋮----
// More detailed error response
⋮----
// Log Stripe event if available
⋮----
// Create HTTP server
⋮----
// Set up WebSocket server
⋮----
// When user authenticates, store connection
⋮----
// Remove connection when socket is closed
</file>

<file path="backend/start-mongo.js">
// Entry point for the MongoDB/Firebase version of the application
</file>

<file path="backend/storage.ts">
import { 
  Profile, InsertProfile, UpsertProfile,
  Club, InsertClub, 
  UserClub, InsertUserClub,
  TeeTimeListing, InsertTeeTimeListing,
  Booking, InsertBooking,
  Review, InsertReview,
  Message, InsertMessage,
  Notification, InsertNotification,
  profiles, clubs, userClubs, teeTimeListing, bookings, reviews, messages, notifications
} from "@shared/schema";
⋮----
import session from "express-session";
⋮----
// Storage interface for all our models
export interface IStorage {
  // Session store
  sessionStore: any;
  
  // User operations (now using Profile types)
  getUser(id: string): Promise<Profile | undefined>;
  getUserByUsername(username: string): Promise<Profile | undefined>;
  getUserByEmail(email: string): Promise<Profile | undefined>;
  getUserByResetToken(resetToken: string): Promise<Profile | undefined>;
  getUserByGoogleId(googleId: string): Promise<Profile | undefined>;
  createUser(user: InsertProfile): Promise<Profile>;
  updateUser(id: string, user: Partial<Profile>): Promise<Profile | undefined>;
  updateUserStripeInfo(id: string, stripeInfo: { customerId: string, connectId?: string }): Promise<Profile | undefined>;
  upsertUser(user: UpsertProfile & { id: string }): Promise<Profile>;
  
  // Club operations
  getClub(id: number): Promise<Club | undefined>;
  getClubs(): Promise<Club[]>;
  createClub(club: InsertClub): Promise<Club>;
  
  // UserClub operations (user IDs are now UUIDs)
  getUserClubs(userId: string): Promise<UserClub[]>;
  addUserToClub(userClub: InsertUserClub): Promise<UserClub>;
  
  // TeeTimeListing operations (host IDs are now UUIDs)
  getTeeTimeListing(id: number): Promise<TeeTimeListing | undefined>;
  getTeeTimeListingsByHostId(hostId: string): Promise<TeeTimeListing[]>;
  getTeeTimeListingsByClubId(clubId: number): Promise<TeeTimeListing[]>;
  getAvailableTeeTimeListings(): Promise<TeeTimeListing[]>;
  createTeeTimeListing(teeTimeListing: InsertTeeTimeListing): Promise<TeeTimeListing>;
  updateTeeTimeListing(id: number, teeTimeListing: Partial<TeeTimeListing>): Promise<TeeTimeListing | undefined>;
  
  // Booking operations (guest IDs are now UUIDs)
  getBooking(id: number): Promise<Booking | undefined>;
  getBookingsByGuestId(guestId: string): Promise<Booking[]>;
  getBookingsByTeeTimeId(teeTimeId: number): Promise<Booking[]>;
  getBookingsByPaymentIntent(paymentIntentId: string): Promise<Booking[]>;
  createBooking(booking: InsertBooking): Promise<Booking>;
  updateBooking(id: number, booking: Partial<Booking>): Promise<Booking | undefined>;
  updateBookingStatus(id: number, status: string): Promise<Booking | undefined>;
  
  // Review operations (reviewer IDs are now UUIDs)
  getReview(id: number): Promise<Review | undefined>;
  getReviewsByTargetId(targetId: string, targetType: string): Promise<Review[]>;
  getReviewsByReviewerId(reviewerId: string): Promise<Review[]>;
  createReview(review: InsertReview): Promise<Review>;
  
  // Message operations (user IDs are now UUIDs)
  getMessage(id: number): Promise<Message | undefined>;
  getMessagesByBookingId(bookingId: number): Promise<Message[]>;
  getConversation(userOneId: string, userTwoId: string): Promise<Message[]>;
  getUserMessages(userId: string): Promise<Message[]>;
  createMessage(message: InsertMessage): Promise<Message>;
  markMessageAsRead(id: number): Promise<Message | undefined>;
  
  // Notification operations (user IDs are now UUIDs)
  getNotification(id: number): Promise<Notification | undefined>;
  getNotificationsByUserId(userId: string): Promise<Notification[]>;
  getUnreadNotificationsByUserId(userId: string): Promise<Notification[]>;
  createNotification(notification: InsertNotification): Promise<Notification>;
  markNotificationAsRead(id: number): Promise<Notification | undefined>;
  markAllNotificationsAsRead(userId: string): Promise<void>;
  
  // Reminder operations
  getRemindersToSend(reminderType: 'one_week' | 'one_day', currentDate: Date): Promise<Booking[]>;
  
  // Pending booking operations
  getPendingBookingsOlderThan(minutes: number): Promise<Booking[]>;
}
⋮----
// Session store
⋮----
// User operations (now using Profile types)
getUser(id: string): Promise<Profile | undefined>;
getUserByUsername(username: string): Promise<Profile | undefined>;
getUserByEmail(email: string): Promise<Profile | undefined>;
getUserByResetToken(resetToken: string): Promise<Profile | undefined>;
getUserByGoogleId(googleId: string): Promise<Profile | undefined>;
createUser(user: InsertProfile): Promise<Profile>;
updateUser(id: string, user: Partial<Profile>): Promise<Profile | undefined>;
updateUserStripeInfo(id: string, stripeInfo:
upsertUser(user: UpsertProfile &
⋮----
// Club operations
getClub(id: number): Promise<Club | undefined>;
getClubs(): Promise<Club[]>;
createClub(club: InsertClub): Promise<Club>;
⋮----
// UserClub operations (user IDs are now UUIDs)
getUserClubs(userId: string): Promise<UserClub[]>;
addUserToClub(userClub: InsertUserClub): Promise<UserClub>;
⋮----
// TeeTimeListing operations (host IDs are now UUIDs)
getTeeTimeListing(id: number): Promise<TeeTimeListing | undefined>;
getTeeTimeListingsByHostId(hostId: string): Promise<TeeTimeListing[]>;
getTeeTimeListingsByClubId(clubId: number): Promise<TeeTimeListing[]>;
getAvailableTeeTimeListings(): Promise<TeeTimeListing[]>;
createTeeTimeListing(teeTimeListing: InsertTeeTimeListing): Promise<TeeTimeListing>;
updateTeeTimeListing(id: number, teeTimeListing: Partial<TeeTimeListing>): Promise<TeeTimeListing | undefined>;
⋮----
// Booking operations (guest IDs are now UUIDs)
getBooking(id: number): Promise<Booking | undefined>;
getBookingsByGuestId(guestId: string): Promise<Booking[]>;
getBookingsByTeeTimeId(teeTimeId: number): Promise<Booking[]>;
getBookingsByPaymentIntent(paymentIntentId: string): Promise<Booking[]>;
createBooking(booking: InsertBooking): Promise<Booking>;
updateBooking(id: number, booking: Partial<Booking>): Promise<Booking | undefined>;
updateBookingStatus(id: number, status: string): Promise<Booking | undefined>;
⋮----
// Review operations (reviewer IDs are now UUIDs)
getReview(id: number): Promise<Review | undefined>;
getReviewsByTargetId(targetId: string, targetType: string): Promise<Review[]>;
getReviewsByReviewerId(reviewerId: string): Promise<Review[]>;
createReview(review: InsertReview): Promise<Review>;
⋮----
// Message operations (user IDs are now UUIDs)
getMessage(id: number): Promise<Message | undefined>;
getMessagesByBookingId(bookingId: number): Promise<Message[]>;
getConversation(userOneId: string, userTwoId: string): Promise<Message[]>;
getUserMessages(userId: string): Promise<Message[]>;
createMessage(message: InsertMessage): Promise<Message>;
markMessageAsRead(id: number): Promise<Message | undefined>;
⋮----
// Notification operations (user IDs are now UUIDs)
getNotification(id: number): Promise<Notification | undefined>;
getNotificationsByUserId(userId: string): Promise<Notification[]>;
getUnreadNotificationsByUserId(userId: string): Promise<Notification[]>;
createNotification(notification: InsertNotification): Promise<Notification>;
markNotificationAsRead(id: number): Promise<Notification | undefined>;
markAllNotificationsAsRead(userId: string): Promise<void>;
⋮----
// Reminder operations
getRemindersToSend(reminderType: 'one_week' | 'one_day', currentDate: Date): Promise<Booking[]>;
⋮----
// Pending booking operations
getPendingBookingsOlderThan(minutes: number): Promise<Booking[]>;
⋮----
export class MemStorage implements IStorage
⋮----
constructor()
⋮----
checkPeriod: 86400000 // prune expired entries every 24h
⋮----
// User operations
async getUser(id: number): Promise<Profile | undefined>
⋮----
async getUserByUsername(username: string): Promise<Profile | undefined>
⋮----
async getUserByEmail(email: string): Promise<Profile | undefined>
⋮----
async getUserByGoogleId(googleId: string): Promise<Profile | undefined>
⋮----
async getUserByResetToken(resetToken: string): Promise<Profile | undefined>
⋮----
async createUser(insertUser: InsertProfile): Promise<Profile>
⋮----
async updateUser(id: number, userData: Partial<Profile>): Promise<Profile | undefined>
⋮----
async updateUserStripeInfo(id: number, stripeInfo:
⋮----
async upsertUser(upsertUser: UpsertProfile &
⋮----
// Update existing user
⋮----
// Create new user
⋮----
// Club operations
async getClub(id: number): Promise<Club | undefined>
⋮----
async getClubs(): Promise<Club[]>
⋮----
async createClub(insertClub: InsertClub): Promise<Club>
⋮----
// UserClub operations
async getUserClubs(userId: string): Promise<UserClub[]>
⋮----
async addUserToClub(insertUserClub: InsertUserClub): Promise<UserClub>
⋮----
// TeeTimeListing operations
async getTeeTimeListing(id: number): Promise<TeeTimeListing | undefined>
⋮----
async getTeeTimeListingsByHostId(hostId: string): Promise<TeeTimeListing[]>
⋮----
async getTeeTimeListingsByClubId(clubId: number): Promise<TeeTimeListing[]>
⋮----
async getAvailableTeeTimeListings(): Promise<TeeTimeListing[]>
⋮----
async createTeeTimeListing(insertTeeTimeListing: InsertTeeTimeListing): Promise<TeeTimeListing>
⋮----
async updateTeeTimeListing(id: number, teeTimeListingData: Partial<TeeTimeListing>): Promise<TeeTimeListing | undefined>
⋮----
// Booking operations
async getBooking(id: number): Promise<Booking | undefined>
⋮----
async getBookingsByGuestId(guestId: string): Promise<Booking[]>
⋮----
async getBookingsByTeeTimeId(teeTimeId: number): Promise<Booking[]>
⋮----
async getBookingsByPaymentIntent(paymentIntentId: string): Promise<Booking[]>
⋮----
async createBooking(insertBooking: InsertBooking): Promise<Booking>
⋮----
async updateBooking(id: number, bookingData: Partial<Booking>): Promise<Booking | undefined>
⋮----
async updateBookingStatus(id: number, status: string): Promise<Booking | undefined>
⋮----
// Review operations
async getReview(id: number): Promise<Review | undefined>
⋮----
async getReviewsByTargetId(targetId: string, targetType: string): Promise<Review[]>
⋮----
async getReviewsByReviewerId(reviewerId: string): Promise<Review[]>
⋮----
async createReview(insertReview: InsertReview): Promise<Review>
⋮----
// Message operations
async getMessage(id: number): Promise<Message | undefined>
⋮----
async getMessagesByBookingId(bookingId: number): Promise<Message[]>
⋮----
async getConversation(userOneId: string, userTwoId: string): Promise<Message[]>
⋮----
async getUserMessages(userId: string): Promise<Message[]>
⋮----
.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime()); // newest first
⋮----
async createMessage(insertMessage: InsertMessage): Promise<Message>
⋮----
async markMessageAsRead(id: number): Promise<Message | undefined>
⋮----
// Notification operations
async getNotification(id: number): Promise<Notification | undefined>
⋮----
async getNotificationsByUserId(userId: string): Promise<Notification[]>
⋮----
.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime()); // newest first
⋮----
async getUnreadNotificationsByUserId(userId: string): Promise<Notification[]>
⋮----
.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime()); // newest first
⋮----
async createNotification(insertNotification: InsertNotification): Promise<Notification>
⋮----
async markNotificationAsRead(id: number): Promise<Notification | undefined>
⋮----
async markAllNotificationsAsRead(userId: string): Promise<void>
⋮----
// Reminder operations
async getRemindersToSend(reminderType: 'one_week' | 'one_day', currentDate: Date): Promise<Booking[]>
⋮----
// Pending booking operations
async getPendingBookingsOlderThan(minutes: number): Promise<Booking[]>
⋮----
import { DatabaseStorage } from './database-storage';
</file>

<file path="backend/vite.ts">
import express, { type Express } from "express";
import fs from "fs";
import path from "path";
import { createServer as createViteServer, createLogger } from "vite";
import { type Server } from "http";
import viteConfig from "../vite.config";
import { nanoid } from "nanoid";
⋮----
export function log(message: string, source = "express")
⋮----
export async function setupVite(app: Express, server: Server)
⋮----
// always reload the index.html file from disk incase it changes
⋮----
export function serveStatic(app: Express)
⋮----
// fall through to index.html if the file doesn't exist
</file>

<file path="frontend/public/favicon.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
  <defs>
    <style>
      .cls-1 {
        fill: #205a50;
      }

      .cls-2 {
        fill: #49dcb1;
      }
    </style>
  </defs>
  <circle class="cls-1" cx="167.09" cy="101.08" r="8.38"/>
  <circle class="cls-1" cx="166.45" cy="80.52" r="8.38"/>
  <circle class="cls-1" cx="186.44" cy="92.69" r="8.38"/>
  <circle class="cls-1" cx="182.92" cy="67.19" r="8.38"/>
  <circle class="cls-1" cx="128.8" cy="142.63" r="8.38"/>
  <circle class="cls-1" cx="108.66" cy="141.13" r="8.38"/>
  <circle class="cls-1" cx="119.23" cy="160.4" r="8.38"/>
  <circle class="cls-1" cx="94.08" cy="155.53" r="8.38"/>
  <circle class="cls-1" cx="147.5" cy="134.46" r="8.38"/>
  <circle class="cls-1" cx="162.54" cy="120.57" r="8.38"/>
  <circle class="cls-1" cx="146.03" cy="155.53" r="8.38"/>
  <circle class="cls-1" cx="168.34" cy="140.05" r="8.38"/>
  <circle class="cls-1" cx="182.92" cy="116.62" r="8.38"/>
  <path class="cls-2" d="M109.16,166.95c1.36,1,45.11-7.5,45.11-7.5-1.08-2.66-.26-5.81,2.13-7.4,3.29-2.19,7.55-.74,8.96,2.72l3.44,8.45c1.04,2.57.2,5.51-2.04,7.14l-26.63,19.34-8.32,31.72c-.32,3.07-2.9,5.4-5.99,5.4h-13.18c-3.08,0-5.67-2.33-5.99-5.39l-8.32-31.47-27.74-20.54c-2.28-1.69-3.07-4.75-1.89-7.33l3.44-7.54c1.38-3.02,4.95-4.36,7.97-2.98"/>
  <path class="cls-1" d="M119.23,172.08c-43.77,0-79.38-35.61-79.38-79.38S75.46,13.31,119.23,13.31s79.38,35.61,79.38,79.38-35.61,79.38-79.38,79.38ZM119.23,25.35c-37.14,0-67.35,30.21-67.35,67.35s30.21,67.35,67.35,67.35,67.35-30.21,67.35-67.35S156.37,25.35,119.23,25.35Z"/>
</svg>
</file>

<file path="frontend/src/assets/backgrounds/green-foliage.svg">
<svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <pattern id="foliage" x="0" y="0" width="100" height="100" patternUnits="userSpaceOnUse">
      <rect width="100" height="100" fill="#2e8b57"/>
      <g fill="#3cb371">
        <ellipse cx="25" cy="25" rx="20" ry="15" />
        <ellipse cx="75" cy="25" rx="20" ry="15" />
        <ellipse cx="25" cy="75" rx="20" ry="15" />
        <ellipse cx="75" cy="75" rx="20" ry="15" />
        <ellipse cx="50" cy="50" rx="25" ry="20" />
      </g>
      <g fill="#228b22" opacity="0.7">
        <ellipse cx="0" cy="0" rx="25" ry="20" />
        <ellipse cx="100" cy="0" rx="25" ry="20" />
        <ellipse cx="0" cy="100" rx="25" ry="20" />
        <ellipse cx="100" cy="100" rx="25" ry="20" />
        <ellipse cx="50" cy="0" rx="30" ry="20" />
        <ellipse cx="50" cy="100" rx="30" ry="20" />
        <ellipse cx="0" cy="50" rx="20" ry="30" />
        <ellipse cx="100" cy="50" rx="20" ry="30" />
      </g>
    </pattern>
  </defs>
  <rect width="800" height="600" fill="url(#foliage)" />
</svg>
</file>

<file path="frontend/src/assets/golf-course-1.svg">
<svg width="800" height="600" viewBox="0 0 800 600" xmlns="http://www.w3.org/2000/svg">
  <!-- Base rectangular frame representing a photograph -->
  <rect width="800" height="600" fill="#f0f0f0"/>
  
  <!-- Simplified representation of a golf course landscape -->
  <rect y="350" width="800" height="250" fill="#3d8c40"/> <!-- Fairway -->
  <rect y="240" width="800" height="110" fill="#87c38f"/> <!-- Rough -->
  <rect y="0" width="800" height="240" fill="#87ceeb"/> <!-- Sky -->
  
  <!-- Water hazard -->
  <ellipse cx="600" cy="420" rx="120" ry="60" fill="#1e90ff"/>
  
  <!-- Sand bunkers -->
  <ellipse cx="200" cy="380" rx="50" ry="20" fill="#f5deb3"/>
  <ellipse cx="450" cy="400" rx="40" ry="15" fill="#f5deb3"/>
  
  <!-- Flag -->
  <line x1="700" y1="380" x2="700" y2="320" stroke="#000" stroke-width="2"/>
  <polygon points="700,320 730,330 700,340" fill="#ff0000"/>
  
  <!-- Trees and landscape elements as simplified shapes -->
  <circle cx="100" cy="280" r="40" fill="#2e8b57"/> <!-- Tree -->
  <circle cx="150" cy="270" r="35" fill="#2e8b57"/> <!-- Tree -->
  <circle cx="300" cy="260" r="45" fill="#2e8b57"/> <!-- Tree -->
  <circle cx="650" cy="290" r="50" fill="#2e8b57"/> <!-- Tree -->
  
  <!-- Caption indicating this is a placeholder/illustration -->
  <text x="400" y="580" font-family="Arial" font-size="24" text-anchor="middle" fill="#333">
    Golf Course Stock Photo Placeholder
  </text>
</svg>
</file>

<file path="frontend/src/assets/logo.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
  <!-- Golf ball outline -->
  <circle cx="20" cy="20" r="18" fill="white" stroke="#205A50" stroke-width="2"/>
  
  <!-- Golf ball dimples pattern -->
  <path d="M12 14C12 15.1046 11.1046 16 10 16C8.89543 16 8 15.1046 8 14C8 12.8954 8.89543 12 10 12C11.1046 12 12 12.8954 12 14Z" fill="#205A50"/>
  <path d="M18 10C18 11.1046 17.1046 12 16 12C14.8954 12 14 11.1046 14 10C14 8.89543 14.8954 8 16 8C17.1046 8 18 8.89543 18 10Z" fill="#205A50"/>
  <path d="M24 8C24 9.10457 23.1046 10 22 10C20.8954 10 20 9.10457 20 8C20 6.89543 20.8954 6 22 6C23.1046 6 24 6.89543 24 8Z" fill="#205A50"/>
  <path d="M30 10C30 11.1046 29.1046 12 28 12C26.8954 12 26 11.1046 26 10C26 8.89543 26.8954 8 28 8C29.1046 8 30 8.89543 30 10Z" fill="#205A50"/>
  <path d="M34 16C34 17.1046 33.1046 18 32 18C30.8954 18 30 17.1046 30 16C30 14.8954 30.8954 14 32 14C33.1046 14 34 14.8954 34 16Z" fill="#205A50"/>
  <path d="M34 24C34 25.1046 33.1046 26 32 26C30.8954 26 30 25.1046 30 24C30 22.8954 30.8954 22 32 22C33.1046 22 34 22.8954 34 24Z" fill="#205A50"/>
  <path d="M30 32C30 33.1046 29.1046 34 28 34C26.8954 34 26 33.1046 26 32C26 30.8954 26.8954 30 28 30C29.1046 30 30 30.8954 30 32Z" fill="#205A50"/>
  <path d="M22 34C22 35.1046 21.1046 36 20 36C18.8954 36 18 35.1046 18 34C18 32.8954 18.8954 32 20 32C21.1046 32 22 32.8954 22 34Z" fill="#205A50"/>
  <path d="M14 32C14 33.1046 13.1046 34 12 34C10.8954 34 10 33.1046 10 32C10 30.8954 10.8954 30 12 30C13.1046 30 14 30.8954 14 32Z" fill="#205A50"/>
  <path d="M8 26C8 27.1046 7.10457 28 6 28C4.89543 28 4 27.1046 4 26C4 24.8954 4.89543 24 6 24C7.10457 24 8 24.8954 8 26Z" fill="#205A50"/>
  <path d="M10 20C10 21.1046 9.10457 22 8 22C6.89543 22 6 21.1046 6 20C6 18.8954 6.89543 18 8 18C9.10457 18 10 18.8954 10 20Z" fill="#205A50"/>
  
  <!-- Cross-hatch pattern for dimension -->
  <path d="M16 18C16 19.1046 15.1046 20 14 20C12.8954 20 12 19.1046 12 18C12 16.8954 12.8954 16 14 16C15.1046 16 16 16.8954 16 18Z" fill="#49DCB1"/>
  <path d="M22 16C22 17.1046 21.1046 18 20 18C18.8954 18 18 17.1046 18 16C18 14.8954 18.8954 14 20 14C21.1046 14 22 14.8954 22 16Z" fill="#49DCB1"/>
  <path d="M28 18C28 19.1046 27.1046 20 26 20C24.8954 20 24 19.1046 24 18C24 16.8954 24.8954 16 26 16C27.1046 16 28 16.8954 28 18Z" fill="#49DCB1"/>
  <path d="M26 26C26 27.1046 25.1046 28 24 28C22.8954 28 22 27.1046 22 26C22 24.8954 22.8954 24 24 24C25.1046 24 26 24.8954 26 26Z" fill="#49DCB1"/>
  <path d="M18 28C18 29.1046 17.1046 30 16 30C14.8954 30 14 29.1046 14 28C14 26.8954 14.8954 26 16 26C17.1046 26 18 26.8954 18 28Z" fill="#49DCB1"/>
  <path d="M16 24C16 25.1046 15.1046 26 14 26C12.8954 26 12 25.1046 12 24C12 22.8954 12.8954 22 14 22C15.1046 22 16 22.8954 16 24Z" fill="#49DCB1"/>
  <path d="M22 22C22 23.1046 21.1046 24 20 24C18.8954 24 18 23.1046 18 22C18 20.8954 18.8954 20 20 20C21.1046 20 22 20.8954 22 22Z" fill="#FFD23F"/>
</svg>
</file>

<file path="frontend/src/assets/new-logo.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
  <defs>
    <style>
      .cls-1 {
        fill: #205a50;
      }

      .cls-2 {
        fill: #49dcb1;
      }
    </style>
  </defs>
  <circle class="cls-1" cx="167.09" cy="101.08" r="8.38"/>
  <circle class="cls-1" cx="166.45" cy="80.52" r="8.38"/>
  <circle class="cls-1" cx="186.44" cy="92.69" r="8.38"/>
  <circle class="cls-1" cx="182.92" cy="67.19" r="8.38"/>
  <circle class="cls-1" cx="128.8" cy="142.63" r="8.38"/>
  <circle class="cls-1" cx="108.66" cy="141.13" r="8.38"/>
  <circle class="cls-1" cx="119.23" cy="160.4" r="8.38"/>
  <circle class="cls-1" cx="94.08" cy="155.53" r="8.38"/>
  <circle class="cls-1" cx="147.5" cy="134.46" r="8.38"/>
  <circle class="cls-1" cx="162.54" cy="120.57" r="8.38"/>
  <circle class="cls-1" cx="146.03" cy="155.53" r="8.38"/>
  <circle class="cls-1" cx="168.34" cy="140.05" r="8.38"/>
  <circle class="cls-1" cx="182.92" cy="116.62" r="8.38"/>
  <path class="cls-2" d="M109.16,166.95c1.36,1,45.11-7.5,45.11-7.5-1.08-2.66-.26-5.81,2.13-7.4,3.29-2.19,7.55-.74,8.96,2.72l3.44,8.45c1.04,2.57.2,5.51-2.04,7.14l-26.63,19.34-8.32,31.72c-.32,3.07-2.9,5.4-5.99,5.4h-13.18c-3.08,0-5.67-2.33-5.99-5.39l-8.32-31.47-27.74-20.54c-2.28-1.69-3.07-4.75-1.89-7.33l3.44-7.54c1.38-3.02,4.95-4.36,7.97-2.98"/>
  <path class="cls-1" d="M119.23,172.08c-43.77,0-79.38-35.61-79.38-79.38S75.46,13.31,119.23,13.31s79.38,35.61,79.38,79.38-35.61,79.38-79.38,79.38ZM119.23,25.35c-37.14,0-67.35,30.21-67.35,67.35s30.21,67.35,67.35,67.35,67.35-30.21,67.35-67.35S156.37,25.35,119.23,25.35Z"/>
</svg>
</file>

<file path="frontend/src/components/_dev_examples/QueryExample.tsx">
import { useQuery } from '@tanstack/react-query';
import { supabaseQueries } from '@/lib/queryClient';
import { getCurrentUser } from '@/lib/supabaseClient';
import { useEffect, useState } from 'react';
⋮----
// Type definitions for query results
interface Profile {
  id: string;
  username: string | null;
  first_name: string | null;
  last_name: string | null;
  profile_image_url: string | null;
  is_host: boolean;
  onboarding_completed: boolean;
  bio: string | null;
}
⋮----
interface Club {
  id: number;
  name: string;
  location: string;
  description: string | null;
  image_url: string | null;
  created_at: string;
}
⋮----
interface Booking {
  id: string;
  number_of_players: number;
  status: string;
  total_price: number;
  created_at: string;
  tee_time_listings?: {
    clubs?: {
      name: string;
      location: string;
    };
  };
}
⋮----
// Get current user ID
⋮----
async function fetchUserId()
⋮----
// Example 1: Traditional API query (backward compatibility)
⋮----
enabled: false // Disabled since endpoint doesn't exist yet
⋮----
// Example 2: Supabase query for clubs
⋮----
staleTime: 5 * 60 * 1000, // 5 minutes
⋮----
// Example 3: User profile query (only if authenticated)
⋮----
// Example 4: User bookings (only if authenticated)
⋮----
{/* User Profile Section */}
⋮----
{/* Clubs Section */}
⋮----
{/* User Bookings Section */}
⋮----
{/* Query Info */}
⋮----
{/* Example of how legacy API calls would work */}
⋮----
{`// This would throw an error with the new defaultQueryFn:
// useQuery({ queryKey: ['/api/legacy-endpoint'] })
⋮----
// Instead, use explicit queryFn for legacy calls:
// useQuery({
//   queryKey: ['/api/legacy-endpoint'],
//   queryFn: () => apiRequest('GET', '/api/legacy-endpoint')
// })`}
</file>

<file path="frontend/src/components/_dev_examples/SanityCheckComponent.tsx">
import { useEffect, useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { supabaseQueries } from '@/lib/queryClient';
import { getCurrentUser, isAuthenticated } from '@/lib/supabaseClient';
import type { User } from '@supabase/supabase-js';
⋮----
interface Club {
  id: number;
  name: string;
  location: string;
  description: string | null;
  image_url: string | null;
  created_at: string;
}
⋮----
interface Profile {
  id: string;
  username: string | null;
  first_name: string | null;
  last_name: string | null;
  is_host: boolean;
  onboarding_completed: boolean;
}
⋮----
interface TestResult {
  testName: string;
  status: 'pending' | 'success' | 'error' | 'disabled';
  message: string;
  data?: any;
  error?: any;
}
⋮----
// Check authentication state
⋮----
async function checkAuth()
⋮----
// Test 1: Public clubs query (should work regardless of auth state)
⋮----
retry: 1, // Limit retries for faster testing
⋮----
// Test 2: User profile query (should be disabled if not authenticated)
⋮----
// Test 3: Legacy API query (should throw error with helpful message)
⋮----
enabled: false, // Disabled by default to prevent error spam
⋮----
// Update test results when queries change
⋮----
// Console logging for detailed debugging
⋮----
// Function to test legacy API error
const testLegacyApiError = () =>
⋮----
// This will trigger the error in our defaultQueryFn
// We'll handle this by creating a temporary query
⋮----
const getStatusIcon = (status: TestResult['status']) =>
⋮----
const getStatusColor = (status: TestResult['status']) =>
⋮----
{/* Test Results */}
⋮----
<span className="text-xl">
⋮----
{/* Manual Test Buttons */}
⋮----
{/* Console Logging Guide */}
</file>

<file path="frontend/src/components/_dev_examples/SupabaseExample.tsx">
import { useEffect, useState } from 'react';
import { supabase, getCurrentUser, getCurrentUserProfile } from '@/lib/supabaseClient';
import type { User } from '@supabase/supabase-js';
⋮----
interface Club {
  id: number;
  name: string;
  location: string;
  description: string | null;
  image_url: string | null;
  created_at: string;
}
⋮----
interface Profile {
  id: string;
  username: string | null;
  first_name: string | null;
  last_name: string | null;
  bio: string | null;
  is_host: boolean;
  onboarding_completed: boolean;
}
⋮----
async function fetchData()
⋮----
// Fetch clubs (public data - no auth required)
⋮----
// Get current user and profile (if authenticated)
⋮----
// Listen for auth state changes
⋮----
// Cleanup subscription
⋮----
{/* Authentication Status */}
⋮----
{/* Clubs Data */}
⋮----
{/* Sample Auth Actions */}
</file>

<file path="frontend/src/components/auth/CheckEmailModal.tsx">
import { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Mail, Loader2 } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/lib/supabaseClient";
⋮----
interface CheckEmailModalProps {
  isOpen: boolean;
  onClose: () => void;
  email: string | null;
}
⋮----
const handleResendEmail = async () =>
</file>

<file path="frontend/src/components/chat/chat-window.tsx">
import { useState, useEffect, useRef } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import MessageList from "./message-list";
import MessageInput from "./message-input";
import { useChat } from "@/hooks/use-chat";
import { Message, ChatUser } from "@/context/chat-context";
import { Loader2 } from "lucide-react";
⋮----
interface ChatWindowProps {
  recipient: ChatUser;
  bookingId?: number;
}
⋮----
export default function ChatWindow(
⋮----
// Scroll to bottom when messages change
⋮----
// Mark messages as read when window is focused
⋮----
const handleSendMessage = (content: string) =>
</file>

<file path="frontend/src/components/chat/message-input.tsx">
import { useState, KeyboardEvent } from "react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { SendHorizonal } from "lucide-react";
⋮----
interface MessageInputProps {
  value: string;
  onChange: (value: string) => void;
  onSend: (message: string) => void;
  placeholder?: string;
  disabled?: boolean;
}
⋮----
export default function MessageInput({
  value,
  onChange,
  onSend,
  placeholder = "Type a message...",
  disabled = false
}: MessageInputProps)
⋮----
const handleSend = async () =>
⋮----
const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) =>
</file>

<file path="frontend/src/components/chat/message-list.tsx">
import { Message } from "@/context/chat-context";
import { useAuth } from "@/hooks/use-auth";
import { cn } from "@/lib/utils";
import { format } from "date-fns";
⋮----
interface MessageListProps {
  messages: Message[];
}
⋮----
const formatMessageTime = (date: Date) =>
⋮----
const formatMessageDate = (date: Date) =>
⋮----
// Group messages by date
</file>

<file path="frontend/src/components/home/become-host.tsx">
import { Link } from "wouter";
import { Button } from "@/components/ui/button";
import { CheckCircle } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import magnoliaBackground from "@/assets/images/magnolia-background.jpg";
⋮----
const handleBecomeHost = () =>
</file>

<file path="frontend/src/components/home/cta-section.tsx">
import { Link } from "wouter";
import { Button } from "@/components/ui/button";
import { useAuth } from "@/hooks/use-auth";
⋮----
const handleFindTeeTimesClick = () =>
⋮----
const handleBecomeHostClick = () =>
⋮----
const handleSignUpClick = () =>
</file>

<file path="frontend/src/components/home/featured-tee-times.tsx">
import { useState, useEffect } from "react";
import { Link } from "wouter";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { useToast } from "@/hooks/use-toast";
import { useTeeTimeListings, type TeeTimeListing } from "@/hooks/use-tee-times";
import { useAuth } from "@/hooks/use-auth";
import { Heart, Star } from "lucide-react";
⋮----
// Only get the first 3 tee times for featured section
⋮----
const toggleFavorite = (id: number) =>
⋮----
const formatDate = (dateString: string) =>
</file>

<file path="frontend/src/components/home/hero-section.tsx">
import { useLocation } from "wouter";
import SearchFilters, { SearchFilters as SearchFiltersType } from "@/components/listings/search-filters";
import { Button } from "@/components/ui/button";
import { useAuth } from "@/hooks/use-auth";
⋮----
const handleSearch = (filters: SearchFiltersType) =>
⋮----
{/* Sign-up CTA for non-authenticated users */}
⋮----
{/* Using the same SearchFilters component that's on the Find Tee Times page */}
</file>

<file path="frontend/src/components/home/how-it-works.tsx">
import { Search, CalendarCheck, Flag } from "lucide-react";
⋮----
export default function HowItWorksSection()
</file>

<file path="frontend/src/components/home/testimonials.tsx">
import { Star } from "lucide-react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
⋮----
interface Testimonial {
  id: number;
  content: string;
  rating: number;
  author: {
    name: string;
    location: string;
    avatar: string;
    initials: string;
  };
}
⋮----
</file>

<file path="frontend/src/components/home/top-destinations.tsx">
import { Link } from "wouter";
⋮----
interface Destination {
  id: number;
  name: string;
  image: string;
  teeTimeCount: number;
}
</file>

<file path="frontend/src/components/listings/search-filters.tsx">
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { 
  Popover, 
  PopoverContent, 
  PopoverTrigger 
} from "@/components/ui/popover";
import { 
  Select, 
  SelectContent, 
  SelectItem, 
  SelectTrigger, 
  SelectValue 
} from "@/components/ui/select";
import { Calendar } from "@/components/ui/calendar";
import { DateRange } from "react-day-picker";
import { format, addDays, isSaturday, isSunday, startOfWeek, nextSaturday } from "date-fns";
import { cn } from "@/lib/utils";
import { MapPin, Calendar as CalendarIcon, Users2, ChevronDown, Filter, Search, Zap } from "lucide-react";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
⋮----
export interface SearchFiltersProps {
  onSearch: (filters: SearchFilters) => void;
  initialFilters?: SearchFilters;
  className?: string;
  isCompact?: boolean;
}
⋮----
export interface SearchFilters {
  location: string;
  date?: Date;
  endDate?: Date;
  players: string;
  distance?: string; // Distance in miles
}
⋮----
distance?: string; // Distance in miles
⋮----
// Define quick filter options
⋮----
// Get the next Saturday (or today if it's Saturday)
⋮----
? today // Today is Saturday
: nextSaturday(today); // Get next Saturday
⋮----
// Get Sunday (the day after Saturday)
⋮----
// Apply a quick filter
const applyQuickFilter = (index: number) =>
⋮----
// Submit search with current filters
const submitSearch = (searchFilters = filters) =>
⋮----
const handleSubmit = (e: React.FormEvent) =>
⋮----
// If only one date is selected, use it for both start and end
⋮----
// Clear the dates if nothing is selected
⋮----
{/* Filters Section - only show when not in compact mode */}
⋮----
{/* Weekend Filter */}
⋮----
{/* Extra space for future filters */}
</file>

<file path="frontend/src/components/listings/tee-time-card.tsx">
import { useState } from "react";
import { Link } from "wouter";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Heart, Star } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { format } from "date-fns";
⋮----
export interface TeeTimeCardProps {
  id: number;
  clubName: string;
  clubLocation: string;
  clubImageUrl: string;
  hostName: string;
  hostImageUrl?: string;
  hostInitials: string;
  date: string;
  price: number;
  rating: number;
  reviewCount: number;
  isFavorited?: boolean;
  onFavoriteToggle?: (id: number) => void;
}
⋮----
export default function TeeTimeCard({
  id,
  clubName,
  clubLocation,
  clubImageUrl,
  hostName,
  hostImageUrl,
  hostInitials,
  date,
  price,
  rating,
  reviewCount,
  isFavorited = false,
  onFavoriteToggle
}: TeeTimeCardProps)
⋮----
const formatDate = (dateString: string) =>
⋮----
const handleFavoriteClick = (e: React.MouseEvent) =>
⋮----
<span className="font-medium">
</file>

<file path="frontend/src/components/notifications/notification-panel.tsx">
import { useState } from 'react';
import { Bell, Check, MessageSquare, Calendar, X } from 'lucide-react';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { useNotifications, Notification } from '@/hooks/use-notifications';
import { cn } from '@/lib/utils';
import { formatDistanceToNow } from 'date-fns';
import { useLocation } from 'wouter';
⋮----
const handleNotificationClick = (notification: Notification) =>
⋮----
// Mark notification as read
⋮----
// Navigate based on notification type
⋮----
// Close popover
⋮----
const getIcon = (type: string) =>
⋮----
className=
⋮----
setLocation('/notifications');
setOpen(false);
</file>

<file path="frontend/src/components/tee-times/create-tee-time-form.tsx">
import { useState, useEffect } from "react";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { format, addHours } from "date-fns";
import { CalendarIcon, ClockIcon, DollarSign, Users } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Calendar } from "@/components/ui/calendar";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Card, CardContent } from "@/components/ui/card";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { useCreateTeeTime } from "@/hooks/use-tee-times";
import { cn } from "@/lib/utils";
import { useQuery } from "@tanstack/react-query";
⋮----
// Form schema
⋮----
type FormValues = z.infer<typeof formSchema>;
⋮----
interface CreateTeeTimeFormProps {
  initialDate?: Date;
  onSuccess?: () => void;
}
⋮----
// Fetch user clubs from API
⋮----
// Parse clubs from API response
⋮----
// Form definition
⋮----
// Combine date and time on submit
const onSubmit = (values: FormValues) =>
⋮----
// Parse time value and adjust the date
⋮----
// Generate time options for the select (from 6:00 AM to 6:00 PM in 30 min increments)
const generateTimeOptions = () =>
⋮----
<form onSubmit=
⋮----
className=
⋮----
disabled=
⋮----
<SelectItem key=
</file>

<file path="frontend/src/components/ui/accordion.tsx">
import { ChevronDown } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/alert-dialog.tsx">
import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"
</file>

<file path="frontend/src/components/ui/alert.tsx">
import { cva, type VariantProps } from "class-variance-authority"
⋮----
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/aspect-ratio.tsx">

</file>

<file path="frontend/src/components/ui/avatar-group.tsx">
import { AvatarProps, Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { cn } from "@/lib/utils";
⋮----
type AvatarGroupProps = {
  items: {
    image?: string;
    name?: string;
    initials?: string;
  }[];
  limit?: number;
  size?: "sm" | "md" | "lg";
  containerClassName?: string;
};
⋮----
<Avatar key=
</file>

<file path="frontend/src/components/ui/avatar.tsx">
import { cn } from "@/lib/utils"
</file>

<file path="frontend/src/components/ui/badge.tsx">
import { cva, type VariantProps } from "class-variance-authority"
⋮----
import { cn } from "@/lib/utils"
⋮----
export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}
⋮----
<div className=
</file>

<file path="frontend/src/components/ui/breadcrumb.tsx">
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/button.tsx">
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
⋮----
import { cn } from "@/lib/utils"
⋮----
export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}
</file>

<file path="frontend/src/components/ui/calendar.tsx">
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"
⋮----
import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"
⋮----
export type CalendarProps = React.ComponentProps<typeof DayPicker>
⋮----
day_today: "", // Removed highlighting for current day
</file>

<file path="frontend/src/components/ui/card.tsx">
import { cn } from "@/lib/utils"
⋮----
className=
⋮----
<div ref=
</file>

<file path="frontend/src/components/ui/carousel.tsx">
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
⋮----
type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]
⋮----
type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}
⋮----
type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps
⋮----
function useCarousel()
</file>

<file path="frontend/src/components/ui/chart.tsx">
import { cn } from "@/lib/utils"
⋮----
// Format: { THEME_NAME: CSS_SELECTOR }
⋮----
export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}
⋮----
type ChartContextProps = {
  config: ChartConfig
}
⋮----
function useChart()
⋮----
className=
⋮----
<div className=
⋮----
// Helper to extract item config from a payload.
</file>

<file path="frontend/src/components/ui/checkbox.tsx">
import { Check } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/collapsible.tsx">

</file>

<file path="frontend/src/components/ui/command.tsx">
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"
⋮----
className=
</file>

<file path="frontend/src/components/ui/context-menu.tsx">
import { Check, ChevronRight, Circle } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/dialog.tsx">
import { X } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/drawer.tsx">
import { Drawer as DrawerPrimitive } from "vaul"
⋮----
import { cn } from "@/lib/utils"
⋮----
const Drawer = (
⋮----
className=
</file>

<file path="frontend/src/components/ui/dropdown-menu.tsx">
import { Check, ChevronRight, Circle } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/form.tsx">
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"
⋮----
import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"
⋮----
type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}
⋮----
const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) =>
⋮----
const useFormField = () =>
⋮----
type FormItemContextValue = {
  id: string
}
⋮----
<div ref=
⋮----
className=
</file>

<file path="frontend/src/components/ui/hover-card.tsx">
import { cn } from "@/lib/utils"
</file>

<file path="frontend/src/components/ui/input-otp.tsx">
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
⋮----
containerClassName=
className=
⋮----
<div ref=
</file>

<file path="frontend/src/components/ui/input.tsx">
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/label.tsx">
import { cva, type VariantProps } from "class-variance-authority"
⋮----
import { cn } from "@/lib/utils"
</file>

<file path="frontend/src/components/ui/menubar.tsx">
import { Check, ChevronRight, Circle } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/navigation-menu.tsx">
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/pagination.tsx">
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"
⋮----
const Pagination = (
⋮----
className=
⋮----
<li ref=
⋮----
const PaginationPrevious = (
</file>

<file path="frontend/src/components/ui/popover.tsx">
import { cn } from "@/lib/utils"
</file>

<file path="frontend/src/components/ui/progress.tsx">
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/radio-group.tsx">
import { Circle } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/resizable.tsx">
import { GripVertical } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
</file>

<file path="frontend/src/components/ui/scroll-area.tsx">
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/select.tsx">
import { Check, ChevronDown, ChevronUp } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/separator.tsx">
import { cn } from "@/lib/utils"
</file>

<file path="frontend/src/components/ui/sheet.tsx">
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
⋮----
interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}
⋮----
className=
</file>

<file path="frontend/src/components/ui/sidebar.tsx">
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"
⋮----
import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
⋮----
type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}
⋮----
function useSidebar()
⋮----
// This is the internal state of the sidebar.
// We use openProp and setOpenProp for control from outside the component.
⋮----
// This sets the cookie to keep the sidebar state.
⋮----
// Helper to toggle the sidebar.
⋮----
// Adds a keyboard shortcut to toggle the sidebar.
⋮----
const handleKeyDown = (event: KeyboardEvent) =>
⋮----
// We add a state so that we can do data-state="expanded" or "collapsed".
// This makes it easier to style the sidebar with Tailwind classes.
⋮----
className=
⋮----
{/* This is what handles the sidebar gap on desktop */}
⋮----
// Adjust the padding for floating and inset variants.
⋮----
onClick?.(event)
toggleSidebar()
⋮----
// Increases the hit area of the button on mobile.
⋮----
// Increases the hit area of the button on mobile.
⋮----
// Random width between 50 to 90%.
</file>

<file path="frontend/src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/slider.tsx">
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/switch.tsx">
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/table.tsx">
import { cn } from "@/lib/utils"
⋮----
className=
⋮----
<thead ref=
</file>

<file path="frontend/src/components/ui/tabs.tsx">
import { cn } from "@/lib/utils"
</file>

<file path="frontend/src/components/ui/textarea.tsx">
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/ui/toast.tsx">
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"
⋮----
import { cn } from "@/lib/utils"
⋮----
className=
⋮----
type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>
⋮----
type ToastActionElement = React.ReactElement<typeof ToastAction>
</file>

<file path="frontend/src/components/ui/toaster.tsx">
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"
</file>

<file path="frontend/src/components/ui/toggle-group.tsx">
import { type VariantProps } from "class-variance-authority"
⋮----
import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"
⋮----
className=
</file>

<file path="frontend/src/components/ui/toggle.tsx">
import { cva, type VariantProps } from "class-variance-authority"
⋮----
import { cn } from "@/lib/utils"
</file>

<file path="frontend/src/components/ui/tooltip.tsx">
import { cn } from "@/lib/utils"
</file>

<file path="frontend/src/components/ui/visually-hidden.tsx">
import { cn } from "@/lib/utils"
⋮----
className=
</file>

<file path="frontend/src/components/custom-link.tsx">
import { ReactNode } from 'react';
import { Link as WouterLink } from 'wouter';
⋮----
type CustomLinkProps = {
  href: string;
  children: ReactNode;
  className?: string;
  onClick?: (e: React.MouseEvent<HTMLAnchorElement>) => void;
};
⋮----
/**
 * Custom Link component that wraps wouter's Link component
 * with automatic scroll-to-top behavior
 */
export default function Link(
⋮----
const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) =>
⋮----
// If provided, run the original onClick handler
⋮----
// If the event wasn't prevented by the onClick handler,
// scroll to top after navigation
</file>

<file path="frontend/src/components/scroll-restoration.tsx">
import { useEffect } from 'react';
import { useLocation } from 'wouter';
⋮----
/**
 * ScrollRestoration component automatically scrolls to top when navigating to a new page
 * This component should be placed high in the component tree (like in App.tsx)
 */
export default function ScrollRestoration()
⋮----
// Scroll to top when location changes
</file>

<file path="frontend/src/context/chat-context.tsx">
import { createContext, useEffect, useRef, useState, ReactNode } from "react";
import { useAuth } from "@/hooks/use-auth";
import { apiRequest } from "@/lib/queryClient";
⋮----
export interface Message {
  id: number;
  senderId: number;
  receiverId: number;
  bookingId?: number;
  content: string;
  isRead: boolean;
  createdAt: string;
}
⋮----
export interface ChatUser {
  id: number;
  name: string;
  profileImage?: string;
}
⋮----
interface ChatContextType {
  connect: () => void;
  disconnect: () => void;
  isConnected: boolean;
  getMessages: (userId: number, bookingId?: number) => Promise<Message[]>;
  sendMessage: (receiverId: number, content: string, bookingId?: number) => Promise<Message>;
  markMessageAsRead: (messageId: number) => Promise<void>;
  unreadMessageCount: number;
}
⋮----
interface ChatProviderProps {
  children: ReactNode;
}
⋮----
export function ChatProvider(
⋮----
const connect = () =>
⋮----
// Send authentication message
⋮----
// Clear any reconnect timeout
⋮----
// Handle new incoming message
⋮----
// Try to reconnect after 5 seconds
⋮----
const disconnect = () =>
⋮----
const getMessages = async (userId: number, bookingId?: number): Promise<Message[]> =>
⋮----
// Update unread count
⋮----
// Update unread count
⋮----
const updateUnreadCount = (messages: Message[]) =>
⋮----
const sendMessage = async (receiverId: number, content: string, bookingId?: number): Promise<Message> =>
⋮----
const markMessageAsRead = async (messageId: number): Promise<void> =>
</file>

<file path="frontend/src/hooks/use-animations.ts">
import { useState } from "react";
⋮----
export type AnimationState = "idle" | "hover" | "active" | "success" | "error";
⋮----
export function useAnimationState(defaultState: AnimationState = "idle")
⋮----
const setHover = ()
const setActive = ()
const setIdle = ()
const setSuccess = ()
const setError = ()
⋮----
export function useButtonAnimation()
</file>

<file path="frontend/src/hooks/use-auth.tsx">
import { useContext } from "react";
import { AuthContext } from "@/context/auth-context";
⋮----
export function useAuth()
</file>

<file path="frontend/src/hooks/use-chat.tsx">
import { useState, useEffect, useCallback } from "react";
import { useContext } from "react";
import { ChatContext, Message } from "@/context/chat-context";
import { useAuth } from "@/hooks/use-auth";
⋮----
export function useChat(recipientId?: number, bookingId?: number)
⋮----
// Update local message state to reflect read status
</file>

<file path="frontend/src/hooks/use-mobile.tsx">
export function useIsMobile()
⋮----
const onChange = () =>
</file>

<file path="frontend/src/hooks/use-notifications.tsx">
import { useState, useEffect } from 'react';
import { useQuery, useMutation } from '@tanstack/react-query';
import { useToast } from '@/hooks/use-toast';
import { queryClient, apiRequest } from '@/lib/queryClient';
import { useAuth } from '@/hooks/use-auth';
⋮----
export type Notification = {
  id: number;
  userId: number;
  title: string;
  message: string;
  type: string;
  relatedId: number;
  isRead: boolean;
  createdAt: string;
};
⋮----
export function useNotifications()
⋮----
// Fetch notifications
⋮----
// Fetch unread notification count
⋮----
// Update unread count when data changes
⋮----
// Mark a notification as read
⋮----
// Invalidate notifications queries to refresh data
⋮----
// Mark all notifications as read
⋮----
// Invalidate notifications queries to refresh data
</file>

<file path="frontend/src/hooks/use-profile.tsx">
import { useQuery } from "@tanstack/react-query";
⋮----
// Interface for user clubs data from Supabase
export interface UserClub {
  id: string;
  user_id: string;
  club_id: string;
  member_since: string;
  clubs: {
    id: string;
    name: string;
    location: string;
  };
}
⋮----
// Interface for tee time listings from Supabase
export interface TeeTimeListing {
  id: string;
  host_id: string;
  club_id: string;
  date: string;
  price: number;
  players_allowed: number;
  notes?: string;
  status: string;
  created_at: string;
  clubs?: {
    id: string;
    name: string;
    location: string;
    image_url?: string;
  };
  bookings?: any[];
}
⋮----
/**
 * Hook to fetch user clubs for a specific user using Supabase
 * @param userId - The user ID to fetch clubs for
 * @param enabled - Whether the query should be enabled
 */
export function useUserClubs(userId?: string, enabled: boolean = true)
⋮----
/**
 * Hook to fetch tee time listings for a specific host using Supabase
 * @param hostId - The host user ID to fetch listings for
 * @param enabled - Whether the query should be enabled
 */
export function useHostTeeTimeListingsSupabase(hostId?: string, enabled: boolean = true)
⋮----
/**
 * Hook to fetch all available tee time listings using Supabase
 * @param limit - Maximum number of listings to fetch
 */
export function useAvailableTeeTimeListings(limit?: number)
⋮----
/**
 * Hook to fetch tee time listings by club ID using Supabase
 * @param clubId - The club ID to fetch listings for
 * @param limit - Maximum number of listings to fetch
 */
export function useTeeTimeListingsByClub(clubId?: number, limit?: number)
⋮----
// Interface for club data from Supabase
export interface Club {
  id: number;
  name: string;
  location: string;
  description?: string;
  image_url?: string;
  created_at: string;
}
⋮----
/**
 * Hook to fetch all clubs using Supabase
 * @param limit - Maximum number of clubs to fetch
 */
export function useClubs(limit?: number)
⋮----
/**
 * Hook to search clubs by name using Supabase
 * @param searchTerm - The search term to filter clubs
 * @param limit - Maximum number of clubs to fetch
 */
export function useClubSearch(searchTerm: string, limit = 10)
</file>

<file path="frontend/src/hooks/use-toast.ts">
import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"
⋮----
type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}
⋮----
function genId()
⋮----
type ActionType = typeof actionTypes
⋮----
type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }
⋮----
interface State {
  toasts: ToasterToast[]
}
⋮----
const addToRemoveQueue = (toastId: string) =>
⋮----
export const reducer = (state: State, action: Action): State =>
⋮----
// ! Side effects ! - This could be extracted into a dismissToast() action,
// but I'll keep it here for simplicity
⋮----
function dispatch(action: Action)
⋮----
type Toast = Omit<ToasterToast, "id">
⋮----
function toast(
⋮----
const update = (props: ToasterToast)
const dismiss = () => dispatch(
⋮----
function useToast()
</file>

<file path="frontend/src/layouts/Footer.tsx">
import { Link } from "wouter";
import { Facebook, Twitter, Instagram, Linkedin } from "lucide-react";
import golfBallLogo from "@/assets/new-logo.svg";
⋮----
export default function Footer()
</file>

<file path="frontend/src/layouts/Navbar.tsx">
import { useState, useEffect } from "react";
import { Link, useLocation } from "wouter";
import { useAuth } from "@/hooks/use-auth";
import { 
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import { Menu, LogOut, User, MessageSquare, Calendar, Bell } from "lucide-react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { NotificationPanel } from "@/components/notifications/notification-panel";
import golfBallLogo from "@/assets/new-logo.svg";
⋮----
// Update local state when user data changes
⋮----
const getInitials = () =>
⋮----
// Helper function to handle Host Your Club click
const handleHostYourClubClick = (e: React.MouseEvent) =>
⋮----
{/* Desktop Menu */}
⋮----

⋮----
{/* Mobile Menu Button */}
⋮----
const shouldContinue = link.onClick(e);
⋮----
setIsSheetOpen(false);
</file>

<file path="frontend/src/lib/supabaseClient.ts">
import { createClient, SupabaseClient } from '@supabase/supabase-js';
⋮----
// Environment variables validation
⋮----
// Validate required environment variables
⋮----
// Create and configure Supabase client
⋮----
// Enable automatic refresh of auth tokens
⋮----
// Persist auth state across browser sessions
⋮----
// Detect auth state changes and update accordingly
⋮----
// Configure auth flow for Vite development
⋮----
// Additional configuration for development
⋮----
// Configure realtime settings if needed
⋮----
// Helper function to check if user is authenticated
export const isAuthenticated = async (): Promise<boolean> =>
⋮----
// Helper function to get current user
export const getCurrentUser = async () =>
⋮----
// Helper function to get current user's profile
export const getCurrentUserProfile = async () =>
⋮----
// Export types for better TypeScript support
⋮----
// Log successful initialization in development
</file>

<file path="frontend/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";
⋮----
export function cn(...inputs: ClassValue[])
⋮----
// Format date to readable string
export function formatDate(date: Date | string, options?: Intl.DateTimeFormatOptions): string
⋮----
// Format time to readable string
export function formatTime(date: Date | string): string
⋮----
// Format price to readable string
export function formatPrice(price: number): string
⋮----
// Calculate time difference between two dates
export function getTimeDifference(date1: Date | string, date2: Date | string): string
⋮----
// Get initials from a name
export function getInitials(name: string): string
⋮----
// Parse URL query parameters
export function parseQueryParams<T>(searchParams: URLSearchParams): Partial<T>
⋮----
// Try to parse as a number
</file>

<file path="frontend/src/pages/about.tsx">
import { Helmet } from "react-helmet";
import { Link } from "wouter";
import { Button } from "@/components/ui/button";
import { ArrowRight, Award, Users, Shield, Calendar } from "lucide-react";
import golfBallLogo from "@/assets/new-logo.svg";
⋮----
export default function AboutPage()
⋮----
{/* Hero Section */}
⋮----
{/* Removed gradient */}
⋮----
{/* Stats Section */}
⋮----
{/* Our Story Section */}
⋮----
{/* How It Works Section */}
⋮----
{/* Our Values Section */}
⋮----
{/* CTA Section */}
</file>

<file path="frontend/src/pages/checkout.tsx">
import { useEffect, useState } from "react";
import { useParams, useLocation } from "wouter";
import { useQuery } from "@tanstack/react-query";
import { useAuth } from "@/hooks/use-auth";
import { useCreatePaymentIntent } from "@/hooks/use-tee-times";
import { useStripe, useElements, Elements, PaymentElement } from "@stripe/react-stripe-js";
import { loadStripe } from "@stripe/stripe-js";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Separator } from "@/components/ui/separator";
import { useToast } from "@/hooks/use-toast";
import { formatDate, formatTime } from "@/lib/utils";
import { AlertCircle, ArrowLeft, CalendarDays, Clock, Loader2, Users } from "lucide-react";
import { Helmet } from 'react-helmet';
⋮----
// Verify Stripe API keys
⋮----
// Initialize Stripe outside of component to avoid recreating on every render
// Only allow card payments
⋮----
// Hook for manual booking confirmation when regular flow fails
function useManualBookingConfirmation()
⋮----
// Add a short delay before confirmation to allow Stripe's systems to process
⋮----
// First check if booking exists and its current status
⋮----
// If booking is already confirmed, no need to continue
⋮----
// Continue with confirmation attempt even if check fails
⋮----
// Proceed with manual confirmation
⋮----
timestamp: Date.now(), // Add timestamp for idempotency
⋮----
// Handle different response types
⋮----
// Check if booking was already confirmed (still a success)
⋮----
// Check if booking was newly confirmed
⋮----
// If we reach here, we got an OK response but not a confirmed booking
⋮----
// Don't show toasts here - let the caller handle error display
// This allows for better retry logic and context-specific messaging
⋮----
const handleSubmit = async (e: React.FormEvent) =>
⋮----
// Use the simplest confirmation flow with mandatory redirect
⋮----
// Make the customer return to their dashboard after payment
⋮----
// Always redirect to avoid client-side handling
⋮----
// This code should never execute due to the redirect
⋮----
// Extremely minimal options to avoid issues
⋮----
// Redirect to login if not authenticated
⋮----
// Fetch booking details
⋮----
// Create payment intent when booking data is loaded
⋮----
// If a booking already exists, check its status first
⋮----
const handleSuccessfulPayment = () =>
</file>

<file path="frontend/src/pages/contact.tsx">
import { Helmet } from "react-helmet";
import { useState } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { toast } from "@/hooks/use-toast";
import { Mail, Phone, MapPin } from "lucide-react";
⋮----
// Define the form schema with validation
⋮----
type FormData = z.infer<typeof formSchema>;
⋮----
// Initialize the form with default values
⋮----
const onSubmit = async (data: FormData) =>
⋮----
// Simulate API call
⋮----
<form onSubmit=
</file>

<file path="frontend/src/pages/cookie-policy.tsx">
import { Helmet } from "react-helmet";
</file>

<file path="frontend/src/pages/EditListingPage.tsx">
import { useEffect } from "react";
import { useParams, useLocation } from "wouter";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useQuery } from "@tanstack/react-query";
import { useAuth } from "@/hooks/use-auth";
import { useUpdateTeeTime } from "@/hooks/use-tee-times";
import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";
import { format, parse } from "date-fns";
import { CalendarIcon, Loader2, AlertCircle, Building, MapPin, ArrowLeft } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { Helmet } from 'react-helmet';
⋮----
// Time options for tee times
⋮----
// Status options for tee time listings
⋮----
// Zod validation schema for updating listings
⋮----
type UpdateListingFormValues = z.infer<typeof updateListingSchema>;
⋮----
// Interface for user clubs from Supabase
interface UserClub {
  id: string;
  user_id: string;
  club_id: number;
  member_since: string;
  clubs: {
    id: number;
    name: string;
    location: string;
    description?: string;
  };
}
⋮----
// Interface for tee time listing from Supabase
interface TeeTimeListing {
  id: string;
  host_id: string;
  club_id: number;
  date: string;
  price: number;
  players_allowed: number;
  notes?: string;
  status: string;
  created_at: string;
  clubs?: {
    id: number;
    name: string;
    location: string;
    image_url?: string;
  };
}
⋮----
// Redirect to login if not authenticated
⋮----
// Redirect if not a host
⋮----
// Fetch the existing tee time listing
⋮----
// Fetch user's affiliated clubs using Supabase
⋮----
// Authorization check - ensure user owns this listing
⋮----
// Pre-fill form when listing data is loaded
⋮----
const onSubmit = (data: UpdateListingFormValues) =>
⋮----
// Combine date and time into a single Date object
⋮----
// Validate that the date/time is in the future (unless it's being cancelled)
⋮----
// Don't render anything while checking authentication
⋮----
// Loading state for listing
⋮----
// Error state for listing fetch
⋮----
// Error state for clubs fetch
⋮----
<form onSubmit=
{/* Club Selection */}
⋮----
{/* Date and Time */}
⋮----
disabled=
⋮----
{/* Price and Players */}
⋮----
{/* Status */}
⋮----
{/* Notes */}
⋮----
{/* Action Buttons */}
</file>

<file path="frontend/src/pages/help.tsx">
import { Helmet } from "react-helmet";
import { useState } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Search, ChevronDown, User, Calendar, CreditCard, Users, MessageSquare, Shield, Clock } from "lucide-react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { Link } from "wouter";
⋮----
// Help center categories and FAQs data
⋮----
// Filter FAQs based on search query
⋮----
<p className="text-muted-foreground text-sm mb-3">
⋮----
onClick=
</file>

<file path="frontend/src/pages/home.tsx">
import HeroSection from "@/components/home/hero-section";
import FeaturedTeeTimesSection from "@/components/home/featured-tee-times";
import HowItWorksSection from "@/components/home/how-it-works";
import BecomeHostSection from "@/components/home/become-host";
import TopDestinationsSection from "@/components/home/top-destinations";
import TestimonialsSection from "@/components/home/testimonials";
import CtaSection from "@/components/home/cta-section";
import Footer from "@/layouts/Footer";
import { Helmet } from 'react-helmet';
⋮----
export default function Home()
</file>

<file path="frontend/src/pages/messages.tsx">
import { useState, useEffect } from "react";
import { useParams, useLocation } from "wouter";
import { useAuth } from "@/hooks/use-auth";
import { useQuery } from "@tanstack/react-query";
import { Card, CardContent } from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Search } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import ChatWindow from "@/components/chat/chat-window";
import { ChatUser } from "@/context/chat-context";
import { useToast } from "@/hooks/use-toast";
import { cn } from "@/lib/utils";
import { Helmet } from 'react-helmet';
⋮----
// Redirect to login if not authenticated
⋮----
// Fetch conversations/contacts
⋮----
// If user ID is provided in URL, fetch that user's details
⋮----
// Look for the user in existing conversations first
⋮----
// If not found in conversations, fetch from the API
⋮----
isOnline: false // We don't track this in real-time yet
⋮----
// Filter contacts based on search query
⋮----
// Set active conversation from URL param
⋮----
// If no specific user ID in URL, select the first conversation
⋮----
const formatLastMessageTime = (dateString: string) =>
⋮----
// Today: show time
⋮----
// Yesterday
⋮----
// Earlier: show date
⋮----
const handleConversationSelect = (userId: number) =>
⋮----
// Update URL without page reload
⋮----
// Prepare recipient data for chat window
⋮----
{/* Contacts/Conversations Sidebar */}
⋮----
className=
⋮----
{/* Chat Area */}
</file>

<file path="frontend/src/pages/not-found.tsx">
import { Card, CardContent } from "@/components/ui/card";
import { AlertCircle } from "lucide-react";
⋮----
export default function NotFound()
</file>

<file path="frontend/src/pages/notifications.tsx">
import { useState } from 'react';
import { Bell, Check, MessageSquare, Calendar, Filter, X } from 'lucide-react';
import { useNotifications, Notification } from '@/hooks/use-notifications';
import { cn } from '@/lib/utils';
import { formatDistanceToNow, format } from 'date-fns';
import { useLocation } from 'wouter';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Skeleton } from '@/components/ui/skeleton';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
⋮----
const handleNotificationClick = (notification: Notification) =>
⋮----
// Mark notification as read
⋮----
// Navigate based on notification type
⋮----
const getIcon = (type: string) =>
⋮----
const getFilteredNotifications = () =>
⋮----
className=
</file>

<file path="frontend/src/pages/press.tsx">
import { Helmet } from "react-helmet";
import { CalendarDays } from "lucide-react";
⋮----
export default function PressPage()
</file>

<file path="frontend/src/pages/privacy-policy.tsx">
import { Helmet } from "react-helmet";
</file>

<file path="frontend/src/pages/profile-edit.tsx">
import { useState, useEffect, useRef } from "react";
import { useLocation } from "wouter";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useMutation } from "@tanstack/react-query";
import { useAuth } from "@/context/auth-context";
import { Loader2, Upload } from "lucide-react";
⋮----
export default function ProfileEdit()
⋮----
// Use refs for direct DOM access to avoid React's state handling
⋮----
// State only for things we need to display or track
⋮----
// Use auth context
⋮----
// Set initial values of inputs directly using DOM
⋮----
// Set input values directly in the DOM
⋮----
// Update profile mutation
⋮----
// Handle form submission
const handleSubmit = (e: React.FormEvent) =>
⋮----
// Get values directly from refs
⋮----
// Handle file upload
const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>) =>
⋮----
{/* Profile Picture Upload */}
⋮----
{/* Name Fields - using plain HTML elements instead of shadcn components */}
⋮----
{/* Bio Field - using plain HTML textarea */}
⋮----
onClick=
</file>

<file path="frontend/src/pages/terms-of-service.tsx">
import { Helmet } from "react-helmet";
</file>

<file path="frontend/src/pages/UpdatePasswordPage.tsx">
import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useLocation } from "wouter";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Loader2, Lock, AlertCircle, CheckCircle } from "lucide-react";
⋮----
type UpdatePasswordFormValues = z.infer<typeof updatePasswordSchema>;
⋮----
// Use either the auth context loading state or local submitting state
⋮----
// Check if this is a valid password recovery session
⋮----
// Give some time for the auth state to settle after redirect
⋮----
// User is authenticated, which should be the case for password recovery
⋮----
// No authenticated user, likely invalid or expired recovery session
⋮----
// Handle form submission
async function onSubmit(data: UpdatePasswordFormValues)
⋮----
// Call the auth context password update function
⋮----
// Show success toast
⋮----
// Navigate to home page after a short delay to let user see the success message
⋮----
// Handle specific Supabase errors
⋮----
// Set form-level error for immediate user feedback
⋮----
// Also show toast for consistency
⋮----
// Show loading state while determining session validity
⋮----
// Show error state for invalid recovery session
⋮----
// Show the password update form for valid recovery sessions
⋮----
<form onSubmit=
{/* Display form-level errors */}
</file>

<file path="frontend/src/styles/global.css">
/* Import Google Fonts */
⋮----
@tailwind base;
@tailwind components;
@tailwind utilities;
⋮----
:root {
⋮----
/* Primary: #205A50 (dark teal) */
⋮----
/* Secondary: #49DCB1 (mint green) */
⋮----
/* Tertiary: #FFD23F (gold) */
⋮----
/* Blue accent: #1B81EE */
⋮----
/* Lighter shade of gold accent */
⋮----
/* Darker shade of gold accent */
⋮----
/* Lighter shade of blue accent */
⋮----
/* Darker shade of blue accent */
⋮----
.dark {
⋮----
/* Primary: #205A50 (dark teal) - slightly lighter in dark mode */
⋮----
@layer base {
⋮----
* {
⋮----
@apply border-border;
⋮----
body {
⋮----
h1, h2, h3, h4, h5, h6 {
⋮----
@apply font-heading;
⋮----
/* Additional styling */
⋮----
.transition-all {
⋮----
/* Override calendar today highlighting */
.rdp-day_today {
⋮----
/* Color utility classes */
.text-accent-gold {
⋮----
.text-accent-gold-light {
⋮----
.text-accent-gold-dark {
⋮----
.text-accent-blue {
⋮----
.text-accent-blue-light {
⋮----
.text-accent-blue-dark {
⋮----
.bg-accent-gold {
⋮----
.bg-accent-gold-light {
⋮----
.bg-accent-gold-dark {
⋮----
.bg-accent-blue {
⋮----
.bg-accent-blue-light {
⋮----
.bg-accent-blue-dark {
⋮----
/* Gradient text */
.text-gradient-gold {
⋮----
.text-gradient-blue {
⋮----
/* Button gradients */
.btn-gradient-gold {
⋮----
.btn-gradient-gold:hover {
⋮----
.btn-gradient-blue {
⋮----
.btn-gradient-blue:hover {
⋮----
/* Hero specific styles */
.hero-gradient {
⋮----
/* Card shadows and effects */
.card-hover {
⋮----
.card-hover:hover {
</file>

<file path="frontend/src/types/react-helmet.d.ts">

</file>

<file path="frontend/src/main.tsx">
import { createRoot } from "react-dom/client";
import App from "./App";
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
    <title>Linx - Book Exclusive Golf Tee Times with Club Members</title>
    <meta name="description" content="Connect with golf club members to book tee times at exclusive courses. Find and play at prestigious golf clubs typically reserved for members only." />
    <meta property="og:title" content="Linx - Book Exclusive Golf Tee Times with Club Members" />
    <meta property="og:description" content="Connect with golf club members to book tee times at exclusive courses. Find and play at prestigious golf clubs typically reserved for members only." />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://images.unsplash.com/photo-1587174486073-ae5e5cff23aa?ixlib=rb-4.0.3&auto=format&fit=crop&w=1200&h=630" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Open+Sans:wght@400;500;600&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <!-- This is a replit script which adds a banner on the top of the page when opened in development mode outside the replit environment -->
    <script type="text/javascript" src="https://replit.com/public/js/replit-dev-banner.js"></script>
  </body>
</html>
</file>

<file path="migrations/meta/0000_snapshot.json">
{
  "id": "baee9a67-4141-4017-b7f8-4b4f83c95d0d",
  "prevId": "00000000-0000-0000-0000-000000000000",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.bookings": {
      "name": "bookings",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "tee_time_id": {
          "name": "tee_time_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "guest_id": {
          "name": "guest_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "number_of_players": {
          "name": "number_of_players",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "status": {
          "name": "status",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "default": "'pending'"
        },
        "stripe_payment_intent_id": {
          "name": "stripe_payment_intent_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "completed_at": {
          "name": "completed_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "total_price": {
          "name": "total_price",
          "type": "double precision",
          "primaryKey": false,
          "notNull": true
        },
        "reminder_one_week": {
          "name": "reminder_one_week",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "reminder_one_day": {
          "name": "reminder_one_day",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "reminder_one_week_sent": {
          "name": "reminder_one_week_sent",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "reminder_one_day_sent": {
          "name": "reminder_one_day_sent",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "bookings_tee_time_id_tee_time_listings_id_fk": {
          "name": "bookings_tee_time_id_tee_time_listings_id_fk",
          "tableFrom": "bookings",
          "tableTo": "tee_time_listings",
          "columnsFrom": [
            "tee_time_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "bookings_guest_id_users_id_fk": {
          "name": "bookings_guest_id_users_id_fk",
          "tableFrom": "bookings",
          "tableTo": "users",
          "columnsFrom": [
            "guest_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.clubs": {
      "name": "clubs",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "location": {
          "name": "location",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "image_url": {
          "name": "image_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.messages": {
      "name": "messages",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "sender_id": {
          "name": "sender_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "receiver_id": {
          "name": "receiver_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "booking_id": {
          "name": "booking_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "content": {
          "name": "content",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "is_read": {
          "name": "is_read",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true,
          "default": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "messages_sender_id_users_id_fk": {
          "name": "messages_sender_id_users_id_fk",
          "tableFrom": "messages",
          "tableTo": "users",
          "columnsFrom": [
            "sender_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "messages_receiver_id_users_id_fk": {
          "name": "messages_receiver_id_users_id_fk",
          "tableFrom": "messages",
          "tableTo": "users",
          "columnsFrom": [
            "receiver_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "messages_booking_id_bookings_id_fk": {
          "name": "messages_booking_id_bookings_id_fk",
          "tableFrom": "messages",
          "tableTo": "bookings",
          "columnsFrom": [
            "booking_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.notifications": {
      "name": "notifications",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "message": {
          "name": "message",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "related_id": {
          "name": "related_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "is_read": {
          "name": "is_read",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true,
          "default": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "notifications_user_id_users_id_fk": {
          "name": "notifications_user_id_users_id_fk",
          "tableFrom": "notifications",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.reviews": {
      "name": "reviews",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "reviewer_id": {
          "name": "reviewer_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "target_id": {
          "name": "target_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "target_type": {
          "name": "target_type",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "booking_id": {
          "name": "booking_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "rating": {
          "name": "rating",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "comment": {
          "name": "comment",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "reviews_reviewer_id_users_id_fk": {
          "name": "reviews_reviewer_id_users_id_fk",
          "tableFrom": "reviews",
          "tableTo": "users",
          "columnsFrom": [
            "reviewer_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "reviews_booking_id_bookings_id_fk": {
          "name": "reviews_booking_id_bookings_id_fk",
          "tableFrom": "reviews",
          "tableTo": "bookings",
          "columnsFrom": [
            "booking_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "set null",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.sessions": {
      "name": "sessions",
      "schema": "",
      "columns": {
        "sid": {
          "name": "sid",
          "type": "varchar",
          "primaryKey": true,
          "notNull": true
        },
        "sess": {
          "name": "sess",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": true
        },
        "expire": {
          "name": "expire",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {
        "IDX_session_expire": {
          "name": "IDX_session_expire",
          "columns": [
            {
              "expression": "expire",
              "isExpression": false,
              "asc": true,
              "nulls": "last"
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.tee_time_listings": {
      "name": "tee_time_listings",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "host_id": {
          "name": "host_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "club_id": {
          "name": "club_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "date": {
          "name": "date",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "price": {
          "name": "price",
          "type": "double precision",
          "primaryKey": false,
          "notNull": true
        },
        "players_allowed": {
          "name": "players_allowed",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "default": 4
        },
        "notes": {
          "name": "notes",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "default": "'available'"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "tee_time_listings_host_id_users_id_fk": {
          "name": "tee_time_listings_host_id_users_id_fk",
          "tableFrom": "tee_time_listings",
          "tableTo": "users",
          "columnsFrom": [
            "host_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "tee_time_listings_club_id_clubs_id_fk": {
          "name": "tee_time_listings_club_id_clubs_id_fk",
          "tableFrom": "tee_time_listings",
          "tableTo": "clubs",
          "columnsFrom": [
            "club_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.user_clubs": {
      "name": "user_clubs",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "club_id": {
          "name": "club_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "member_since": {
          "name": "member_since",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "user_clubs_user_id_users_id_fk": {
          "name": "user_clubs_user_id_users_id_fk",
          "tableFrom": "user_clubs",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "user_clubs_club_id_clubs_id_fk": {
          "name": "user_clubs_club_id_clubs_id_fk",
          "tableFrom": "user_clubs",
          "tableTo": "clubs",
          "columnsFrom": [
            "club_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.users": {
      "name": "users",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar",
          "primaryKey": true,
          "notNull": true
        },
        "username": {
          "name": "username",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "password": {
          "name": "password",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "first_name": {
          "name": "first_name",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "last_name": {
          "name": "last_name",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "bio": {
          "name": "bio",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "profile_image": {
          "name": "profile_image",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "profile_image_url": {
          "name": "profile_image_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "is_host": {
          "name": "is_host",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "stripe_customer_id": {
          "name": "stripe_customer_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_connect_id": {
          "name": "stripe_connect_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "google_id": {
          "name": "google_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "users_username_unique": {
          "name": "users_username_unique",
          "nullsNotDistinct": false,
          "columns": [
            "username"
          ]
        },
        "users_email_unique": {
          "name": "users_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        },
        "users_google_id_unique": {
          "name": "users_google_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "google_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}
</file>

<file path="migrations/meta/0001_snapshot.json">
{
  "id": "05109ed1-61b7-4b40-8a3c-748be8fb8a58",
  "prevId": "baee9a67-4141-4017-b7f8-4b4f83c95d0d",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.bookings": {
      "name": "bookings",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "tee_time_id": {
          "name": "tee_time_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "guest_id": {
          "name": "guest_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "number_of_players": {
          "name": "number_of_players",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "status": {
          "name": "status",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "default": "'pending'"
        },
        "stripe_payment_intent_id": {
          "name": "stripe_payment_intent_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "completed_at": {
          "name": "completed_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "total_price": {
          "name": "total_price",
          "type": "double precision",
          "primaryKey": false,
          "notNull": true
        },
        "reminder_one_week": {
          "name": "reminder_one_week",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "reminder_one_day": {
          "name": "reminder_one_day",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "reminder_one_week_sent": {
          "name": "reminder_one_week_sent",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "reminder_one_day_sent": {
          "name": "reminder_one_day_sent",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "bookings_tee_time_id_tee_time_listings_id_fk": {
          "name": "bookings_tee_time_id_tee_time_listings_id_fk",
          "tableFrom": "bookings",
          "tableTo": "tee_time_listings",
          "columnsFrom": [
            "tee_time_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "bookings_guest_id_profiles_id_fk": {
          "name": "bookings_guest_id_profiles_id_fk",
          "tableFrom": "bookings",
          "tableTo": "profiles",
          "columnsFrom": [
            "guest_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.clubs": {
      "name": "clubs",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "location": {
          "name": "location",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "image_url": {
          "name": "image_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.messages": {
      "name": "messages",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "sender_id": {
          "name": "sender_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "receiver_id": {
          "name": "receiver_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "booking_id": {
          "name": "booking_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "content": {
          "name": "content",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "is_read": {
          "name": "is_read",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true,
          "default": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "messages_sender_id_profiles_id_fk": {
          "name": "messages_sender_id_profiles_id_fk",
          "tableFrom": "messages",
          "tableTo": "profiles",
          "columnsFrom": [
            "sender_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "messages_receiver_id_profiles_id_fk": {
          "name": "messages_receiver_id_profiles_id_fk",
          "tableFrom": "messages",
          "tableTo": "profiles",
          "columnsFrom": [
            "receiver_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "messages_booking_id_bookings_id_fk": {
          "name": "messages_booking_id_bookings_id_fk",
          "tableFrom": "messages",
          "tableTo": "bookings",
          "columnsFrom": [
            "booking_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.notifications": {
      "name": "notifications",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "message": {
          "name": "message",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "related_id": {
          "name": "related_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "is_read": {
          "name": "is_read",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true,
          "default": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "notifications_user_id_profiles_id_fk": {
          "name": "notifications_user_id_profiles_id_fk",
          "tableFrom": "notifications",
          "tableTo": "profiles",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.profiles": {
      "name": "profiles",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "uuid",
          "primaryKey": true,
          "notNull": true
        },
        "username": {
          "name": "username",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "first_name": {
          "name": "first_name",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "last_name": {
          "name": "last_name",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "bio": {
          "name": "bio",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "profile_image": {
          "name": "profile_image",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "profile_image_url": {
          "name": "profile_image_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "is_host": {
          "name": "is_host",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "stripe_customer_id": {
          "name": "stripe_customer_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_connect_id": {
          "name": "stripe_connect_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "onboarding_completed": {
          "name": "onboarding_completed",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "profiles_username_unique": {
          "name": "profiles_username_unique",
          "nullsNotDistinct": false,
          "columns": [
            "username"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.reviews": {
      "name": "reviews",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "reviewer_id": {
          "name": "reviewer_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "target_id": {
          "name": "target_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "target_type": {
          "name": "target_type",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "booking_id": {
          "name": "booking_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "rating": {
          "name": "rating",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "comment": {
          "name": "comment",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "reviews_reviewer_id_profiles_id_fk": {
          "name": "reviews_reviewer_id_profiles_id_fk",
          "tableFrom": "reviews",
          "tableTo": "profiles",
          "columnsFrom": [
            "reviewer_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "reviews_booking_id_bookings_id_fk": {
          "name": "reviews_booking_id_bookings_id_fk",
          "tableFrom": "reviews",
          "tableTo": "bookings",
          "columnsFrom": [
            "booking_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "set null",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.sessions": {
      "name": "sessions",
      "schema": "",
      "columns": {
        "sid": {
          "name": "sid",
          "type": "varchar",
          "primaryKey": true,
          "notNull": true
        },
        "sess": {
          "name": "sess",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": true
        },
        "expire": {
          "name": "expire",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {
        "IDX_session_expire": {
          "name": "IDX_session_expire",
          "columns": [
            {
              "expression": "expire",
              "isExpression": false,
              "asc": true,
              "nulls": "last"
            }
          ],
          "isUnique": false,
          "concurrently": false,
          "method": "btree",
          "with": {}
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.tee_time_listings": {
      "name": "tee_time_listings",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "host_id": {
          "name": "host_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "club_id": {
          "name": "club_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "date": {
          "name": "date",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "price": {
          "name": "price",
          "type": "double precision",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "players_allowed": {
          "name": "players_allowed",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "default": 4
        },
        "notes": {
          "name": "notes",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "default": "'available'"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "tee_time_listings_host_id_profiles_id_fk": {
          "name": "tee_time_listings_host_id_profiles_id_fk",
          "tableFrom": "tee_time_listings",
          "tableTo": "profiles",
          "columnsFrom": [
            "host_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "tee_time_listings_club_id_clubs_id_fk": {
          "name": "tee_time_listings_club_id_clubs_id_fk",
          "tableFrom": "tee_time_listings",
          "tableTo": "clubs",
          "columnsFrom": [
            "club_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.user_clubs": {
      "name": "user_clubs",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "uuid",
          "primaryKey": false,
          "notNull": true
        },
        "club_id": {
          "name": "club_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "member_since": {
          "name": "member_since",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "user_clubs_user_id_profiles_id_fk": {
          "name": "user_clubs_user_id_profiles_id_fk",
          "tableFrom": "user_clubs",
          "tableTo": "profiles",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "user_clubs_club_id_clubs_id_fk": {
          "name": "user_clubs_club_id_clubs_id_fk",
          "tableFrom": "user_clubs",
          "tableTo": "clubs",
          "columnsFrom": [
            "club_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}
</file>

<file path="migrations/0000_ancient_nehzno.sql">
CREATE TABLE "bookings" (
	"id" serial PRIMARY KEY NOT NULL,
	"tee_time_id" integer NOT NULL,
	"guest_id" integer NOT NULL,
	"number_of_players" integer NOT NULL,
	"status" text DEFAULT 'pending' NOT NULL,
	"stripe_payment_intent_id" text,
	"created_at" timestamp DEFAULT now(),
	"completed_at" timestamp,
	"total_price" double precision NOT NULL,
	"reminder_one_week" timestamp,
	"reminder_one_day" timestamp,
	"reminder_one_week_sent" boolean DEFAULT false,
	"reminder_one_day_sent" boolean DEFAULT false
);
--> statement-breakpoint
CREATE TABLE "clubs" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"location" text NOT NULL,
	"description" text,
	"image_url" text,
	"created_at" timestamp DEFAULT now()
);
--> statement-breakpoint
CREATE TABLE "messages" (
	"id" serial PRIMARY KEY NOT NULL,
	"sender_id" integer NOT NULL,
	"receiver_id" integer NOT NULL,
	"booking_id" integer,
	"content" text NOT NULL,
	"is_read" boolean DEFAULT false NOT NULL,
	"created_at" timestamp DEFAULT now()
);
--> statement-breakpoint
CREATE TABLE "notifications" (
	"id" serial PRIMARY KEY NOT NULL,
	"user_id" integer NOT NULL,
	"title" text NOT NULL,
	"message" text NOT NULL,
	"type" text NOT NULL,
	"related_id" integer NOT NULL,
	"is_read" boolean DEFAULT false NOT NULL,
	"created_at" timestamp DEFAULT now()
);
--> statement-breakpoint
CREATE TABLE "reviews" (
	"id" serial PRIMARY KEY NOT NULL,
	"reviewer_id" integer NOT NULL,
	"target_id" integer NOT NULL,
	"target_type" text NOT NULL,
	"booking_id" integer,
	"rating" integer NOT NULL,
	"comment" text,
	"created_at" timestamp DEFAULT now()
);
--> statement-breakpoint
CREATE TABLE "sessions" (
	"sid" varchar PRIMARY KEY NOT NULL,
	"sess" jsonb NOT NULL,
	"expire" timestamp NOT NULL
);
--> statement-breakpoint
CREATE TABLE "tee_time_listings" (
	"id" serial PRIMARY KEY NOT NULL,
	"host_id" integer NOT NULL,
	"club_id" integer NOT NULL,
	"date" timestamp NOT NULL,
	"price" double precision NOT NULL,
	"players_allowed" integer DEFAULT 4 NOT NULL,
	"notes" text,
	"status" text DEFAULT 'available' NOT NULL,
	"created_at" timestamp DEFAULT now()
);
--> statement-breakpoint
CREATE TABLE "user_clubs" (
	"id" serial PRIMARY KEY NOT NULL,
	"user_id" integer NOT NULL,
	"club_id" integer NOT NULL,
	"member_since" timestamp DEFAULT now()
);
--> statement-breakpoint
CREATE TABLE "users" (
	"id" varchar PRIMARY KEY NOT NULL,
	"username" text,
	"email" text,
	"password" text,
	"first_name" text,
	"last_name" text,
	"bio" text,
	"profile_image" text,
	"profile_image_url" text,
	"is_host" boolean DEFAULT false,
	"stripe_customer_id" text,
	"stripe_connect_id" text,
	"google_id" text,
	"created_at" timestamp DEFAULT now(),
	"updated_at" timestamp DEFAULT now(),
	CONSTRAINT "users_username_unique" UNIQUE("username"),
	CONSTRAINT "users_email_unique" UNIQUE("email"),
	CONSTRAINT "users_google_id_unique" UNIQUE("google_id")
);
--> statement-breakpoint
ALTER TABLE "bookings" ADD CONSTRAINT "bookings_tee_time_id_tee_time_listings_id_fk" FOREIGN KEY ("tee_time_id") REFERENCES "public"."tee_time_listings"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "bookings" ADD CONSTRAINT "bookings_guest_id_users_id_fk" FOREIGN KEY ("guest_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "messages" ADD CONSTRAINT "messages_sender_id_users_id_fk" FOREIGN KEY ("sender_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "messages" ADD CONSTRAINT "messages_receiver_id_users_id_fk" FOREIGN KEY ("receiver_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "messages" ADD CONSTRAINT "messages_booking_id_bookings_id_fk" FOREIGN KEY ("booking_id") REFERENCES "public"."bookings"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "notifications" ADD CONSTRAINT "notifications_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "reviews" ADD CONSTRAINT "reviews_reviewer_id_users_id_fk" FOREIGN KEY ("reviewer_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "reviews" ADD CONSTRAINT "reviews_booking_id_bookings_id_fk" FOREIGN KEY ("booking_id") REFERENCES "public"."bookings"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tee_time_listings" ADD CONSTRAINT "tee_time_listings_host_id_users_id_fk" FOREIGN KEY ("host_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tee_time_listings" ADD CONSTRAINT "tee_time_listings_club_id_clubs_id_fk" FOREIGN KEY ("club_id") REFERENCES "public"."clubs"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "user_clubs" ADD CONSTRAINT "user_clubs_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "user_clubs" ADD CONSTRAINT "user_clubs_club_id_clubs_id_fk" FOREIGN KEY ("club_id") REFERENCES "public"."clubs"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
CREATE INDEX "IDX_session_expire" ON "sessions" USING btree ("expire");
</file>

<file path="migrations/0001_left_barracuda.sql">
ALTER TABLE "users" RENAME TO "profiles";--> statement-breakpoint
ALTER TABLE "profiles" DROP CONSTRAINT "users_username_unique";--> statement-breakpoint
ALTER TABLE "profiles" DROP CONSTRAINT "users_email_unique";--> statement-breakpoint
ALTER TABLE "profiles" DROP CONSTRAINT "users_google_id_unique";--> statement-breakpoint
ALTER TABLE "bookings" DROP CONSTRAINT "bookings_guest_id_users_id_fk";
--> statement-breakpoint
ALTER TABLE "messages" DROP CONSTRAINT "messages_sender_id_users_id_fk";
--> statement-breakpoint
ALTER TABLE "messages" DROP CONSTRAINT "messages_receiver_id_users_id_fk";
--> statement-breakpoint
ALTER TABLE "notifications" DROP CONSTRAINT "notifications_user_id_users_id_fk";
--> statement-breakpoint
ALTER TABLE "reviews" DROP CONSTRAINT "reviews_reviewer_id_users_id_fk";
--> statement-breakpoint
ALTER TABLE "tee_time_listings" DROP CONSTRAINT "tee_time_listings_host_id_users_id_fk";
--> statement-breakpoint
ALTER TABLE "user_clubs" DROP CONSTRAINT "user_clubs_user_id_users_id_fk";
--> statement-breakpoint
ALTER TABLE "bookings" ALTER COLUMN "guest_id" SET DATA TYPE uuid;--> statement-breakpoint
ALTER TABLE "messages" ALTER COLUMN "sender_id" SET DATA TYPE uuid;--> statement-breakpoint
ALTER TABLE "messages" ALTER COLUMN "receiver_id" SET DATA TYPE uuid;--> statement-breakpoint
ALTER TABLE "notifications" ALTER COLUMN "user_id" SET DATA TYPE uuid;--> statement-breakpoint
ALTER TABLE "reviews" ALTER COLUMN "reviewer_id" SET DATA TYPE uuid;--> statement-breakpoint
ALTER TABLE "reviews" ALTER COLUMN "target_id" SET DATA TYPE text;--> statement-breakpoint
ALTER TABLE "tee_time_listings" ALTER COLUMN "host_id" SET DATA TYPE uuid;--> statement-breakpoint
ALTER TABLE "user_clubs" ALTER COLUMN "user_id" SET DATA TYPE uuid;--> statement-breakpoint
ALTER TABLE "profiles" ALTER COLUMN "id" SET DATA TYPE uuid;--> statement-breakpoint
ALTER TABLE "profiles" ADD COLUMN "onboarding_completed" boolean DEFAULT false;--> statement-breakpoint
ALTER TABLE "bookings" ADD CONSTRAINT "bookings_guest_id_profiles_id_fk" FOREIGN KEY ("guest_id") REFERENCES "public"."profiles"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "messages" ADD CONSTRAINT "messages_sender_id_profiles_id_fk" FOREIGN KEY ("sender_id") REFERENCES "public"."profiles"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "messages" ADD CONSTRAINT "messages_receiver_id_profiles_id_fk" FOREIGN KEY ("receiver_id") REFERENCES "public"."profiles"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "notifications" ADD CONSTRAINT "notifications_user_id_profiles_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "reviews" ADD CONSTRAINT "reviews_reviewer_id_profiles_id_fk" FOREIGN KEY ("reviewer_id") REFERENCES "public"."profiles"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tee_time_listings" ADD CONSTRAINT "tee_time_listings_host_id_profiles_id_fk" FOREIGN KEY ("host_id") REFERENCES "public"."profiles"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "user_clubs" ADD CONSTRAINT "user_clubs_user_id_profiles_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "profiles" DROP COLUMN "email";--> statement-breakpoint
ALTER TABLE "profiles" DROP COLUMN "password";--> statement-breakpoint
ALTER TABLE "profiles" DROP COLUMN "google_id";--> statement-breakpoint
ALTER TABLE "profiles" ADD CONSTRAINT "profiles_username_unique" UNIQUE("username");
</file>

<file path="sql_scripts/database-rls-policies.sql">
-- RLS Policies for ClubKey Database
-- Run these in your Supabase SQL editor

-- Enable RLS on clubs table
ALTER TABLE clubs ENABLE ROW LEVEL SECURITY;

-- Allow everyone (including unauthenticated users) to read clubs
-- This makes sense for a golf booking app where people need to see available clubs
CREATE POLICY "Allow public read access to clubs" ON clubs
  FOR SELECT
  TO public
  USING (true);

-- Optional: Allow authenticated users to read all club details
-- (This policy would be redundant with the public policy above, but kept for reference)
CREATE POLICY "Allow authenticated users to read clubs" ON clubs
  FOR SELECT
  TO authenticated
  USING (true);

-- Note: For testing purposes, you might want to insert some sample data
-- INSERT INTO clubs (name, location, description) VALUES 
--   ('Pine Valley Golf Club', 'New Jersey, USA', 'Championship golf course'),
--   ('Augusta National', 'Georgia, USA', 'Home of the Masters Tournament'),
--   ('St. Andrews', 'Scotland, UK', 'The home of golf');
</file>

<file path="sql_scripts/insert-test-data.sql">
-- Insert test data for clubs table
-- Run this in your Supabase SQL editor after applying the RLS policies

INSERT INTO clubs (name, location, description) VALUES 
  ('Pine Valley Golf Club', 'New Jersey, USA', 'Championship golf course with rolling fairways and challenging greens'),
  ('Augusta National', 'Georgia, USA', 'Home of the Masters Tournament, featuring iconic azaleas and magnolias'),
  ('St. Andrews', 'Scotland, UK', 'The home of golf, where the game was born over 600 years ago'),
  ('Pebble Beach Golf Links', 'California, USA', 'Stunning coastal course with dramatic ocean views'),
  ('Shinnecock Hills', 'New York, USA', 'Historic links-style course hosting multiple US Opens');
</file>

<file path="sql_scripts/missing_reset_token_columns.sql">
-- Missing columns for password reset functionality
-- These were in the original migration.sql but not in Drizzle Kit migrations
-- Run these manually if password reset functionality is needed

ALTER TABLE "profiles" ADD COLUMN IF NOT EXISTS "reset_token" TEXT;
ALTER TABLE "profiles" ADD COLUMN IF NOT EXISTS "reset_token_expiry" TIMESTAMP;
</file>

<file path="sql_scripts/README.md">
# SQL Scripts

This directory contains manually-run SQL scripts that are separate from Drizzle Kit's managed migrations.

## Files

### Manual Database Setup Scripts
- **`database-rls-policies.sql`** - Row Level Security policies for Supabase
- **`insert-test-data.sql`** - Sample data for development/testing

### Column Addition Scripts  
- **`missing_reset_token_columns.sql`** - Adds password reset functionality columns

## Notes

- These scripts should be run manually when needed
- Check if columns already exist before running addition scripts
- The Drizzle Kit migrations in `/migrations/` handle the main schema evolution
</file>

<file path=".cursorindexingignore">
# Don't index SpecStory auto-save files, but allow explicit context inclusion via @ references
.specstory/**
</file>

<file path=".replit">
modules = ["nodejs-20", "web"]
run = "npm run dev"

[nix]
channel = "stable-24_05"

[deployment]
run = ["sh", "-c", "npm run dev"]
</file>

<file path="drizzle.config.ts">
import { defineConfig } from "drizzle-kit";
</file>

<file path="frontend/src/components/auth/login-form.tsx">
import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useToast } from "@/hooks/use-toast";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
import { useAuth } from "@/hooks/use-auth";
import { Loader2 } from "lucide-react";
⋮----
type LoginFormValues = z.infer<typeof loginSchema>;
⋮----
interface LoginFormProps {
  onSuccess: () => void;
  switchToRegister: () => void;
  switchToResetPassword: () => void;
}
⋮----
// Use either the auth context loading state or local submitting state
⋮----
async function onSubmit(data: LoginFormValues)
⋮----
// Call the auth context login function
⋮----
// Show success toast (auth context may also show one, but this is more specific)
⋮----
// Call the success callback to close modal or redirect
⋮----
// The auth context already shows a toast, but we can show a more specific one here
// or handle specific error cases differently
⋮----
// Handle specific Supabase auth errors
⋮----
// Set form-level error for immediate user feedback
⋮----
// Also show toast for consistency
⋮----
<form onSubmit=
{/* Display form-level errors */}
⋮----
{/* Social login section removed */}
</file>

<file path="frontend/src/components/auth/password-reset-form.tsx">
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { Loader2 } from "lucide-react";
⋮----
// Simplified schema for email-only password reset request
⋮----
type PasswordResetRequestValues = z.infer<typeof passwordResetRequestSchema>;
⋮----
interface PasswordResetFormProps {
  switchToLogin: () => void;
  onSuccess?: () => void;
}
⋮----
// Use either the auth context loading state or local submitting state
⋮----
async function onSubmit(data: PasswordResetRequestValues)
⋮----
// Call the auth context password reset function
⋮----
// Mark email as sent for UI feedback
⋮----
// Show success toast (auth context may also show one, but this is more specific)
⋮----
// Optionally call success callback if provided
⋮----
// Handle specific errors
⋮----
// Set form-level error for immediate user feedback
⋮----
// Also show toast for consistency
⋮----
<form onSubmit=
{/* Display form-level errors */}
</file>

<file path="frontend/src/components/dashboard/host-calendar.tsx">
import { useState, useEffect } from "react";
import { format, startOfMonth, endOfMonth, eachDayOfInterval, isSameDay, parse, add, isSameMonth } from "date-fns";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { CalendarIcon, ChevronLeft, ChevronRight, Plus } from "lucide-react";
import { TeeTimeListing as SupabaseTeeTimeListing } from "@/hooks/use-profile";
import { useAuth } from "@/hooks/use-auth";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";
import CreateTeeTimeForm from "../tee-times/create-tee-time-form";
⋮----
type CalendarDay = {
  date: Date;
  isCurrentMonth: boolean;
  teeTimesCount: number;
  teeTimeIds: string[];
  isToday: boolean;
};
⋮----
interface HostCalendarProps {
  teeTimeListings?: SupabaseTeeTimeListing[];
}
⋮----
// Generate calendar days for current month view
⋮----
const generateCalendarDays = () =>
⋮----
// Fill in days from previous/next month to complete the calendar grid (6 rows of 7 days)
const firstDayOfWeek = firstDayOfMonth.getDay(); // 0 = Sunday, 1 = Monday, etc.
⋮----
// Previous month days
⋮----
// Next month days (to fill a 6-row grid)
const totalDaysToShow = 42; // 6 rows of 7 days
⋮----
// Combine all days
⋮----
// Create calendar days with tee time data
⋮----
// Navigate to previous/next month
const goToPreviousMonth = () =>
⋮----
const goToNextMonth = () =>
⋮----
// Reset to current month
const goToCurrentMonth = () =>
⋮----
// Handle day click to show tee times
const handleDayClick = (day: CalendarDay) =>
⋮----
const formatTeeTime = (teeTime: SupabaseTeeTimeListing) =>
⋮----
// Get tee times for selected day
const getSelectedDayTeeTimeListings = () =>
⋮----
{/* Day labels */}
⋮----
{/* Calendar days */}
⋮----
{/* Selected day details */}
</file>

<file path="frontend/src/lib/queryClient.ts">
import { QueryClient, QueryFunction } from "@tanstack/react-query";
import { supabase } from './supabaseClient';
⋮----
/**
 * Legacy API request function for explicit non-Supabase calls
 * Use this explicitly in useQuery when you need to call traditional REST endpoints
 * Example: useQuery({ queryKey: ['/api/endpoint'], queryFn: () => apiRequest('GET', '/api/endpoint') })
 */
export async function apiRequest(
  method: string,
  url: string,
  data?: unknown | undefined,
): Promise<Response>
⋮----
/**
 * Helper function to handle Supabase database queries
 * Supports query patterns like:
 * - ['supabase:table:select', options]
 * - ['supabase:table:single', options]
 */
async function handleSupabaseQuery(
  url: string, 
  queryKey: readonly unknown[]
)
⋮----
// Parse Supabase query format: 'supabase:table:operation'
⋮----
// Handle different operations
⋮----
// Format: ['supabase:profiles:select', { columns: '*', eq: { id: 'uuid' }, limit: 10, order: {...} }]
⋮----
// Apply filters
⋮----
// Handle complex filters object for search functionality
⋮----
// Location filter - search in club names and locations
⋮----
// Date range filters
⋮----
// If only start date, search for that entire day
⋮----
// Players filter - ensure listing allows at least the requested number of players
⋮----
// Always filter for available listings only
⋮----
// Ensure future dates only
⋮----
// Format: ['supabase:profiles:single', { id: 'uuid', columns: '*' }]
⋮----
// Apply filters for single record
⋮----
// Simplified single record lookup by id
⋮----
// Format: ['supabase:table:count', { eq: { status: 'active' } }]
⋮----
// Apply filters for count
⋮----
/**
 * Default Query Function for TanStack Query
 * Primarily handles Supabase queries (queryKey[0] starting with 'supabase:')
 * Throws error for non-Supabase patterns to encourage explicit handling
 */
const defaultQueryFn: QueryFunction = async (
⋮----
// Handle Supabase queries
⋮----
// Reject non-Supabase patterns
⋮----
/**
 * Helper functions for common Supabase query patterns
 * These provide a convenient, type-safe way to construct Supabase queries
 */
⋮----
// Profile queries
⋮----
// Club queries
⋮----
// Booking queries
⋮----
// Tee Time Listing queries
⋮----
// Message queries
⋮----
// Review queries
⋮----
/**
 * Configured TanStack Query Client
 * Uses Supabase-focused defaultQueryFn with optimized caching and error handling
 */
⋮----
staleTime: 30000, // 30 seconds
⋮----
// Don't retry on certain Supabase errors
⋮----
// Don't retry configuration errors
⋮----
// Retry other errors up to 2 times
</file>

<file path="frontend/src/pages/create-listing.tsx">
import { useEffect } from "react";
import { useLocation } from "wouter";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useQuery } from "@tanstack/react-query";
import { useAuth } from "@/hooks/use-auth";
import { useCreateTeeTime } from "@/hooks/use-tee-times";
import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";
import { format } from "date-fns";
import { CalendarIcon, Loader2, AlertCircle, Building, MapPin } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { Helmet } from 'react-helmet';
⋮----
// Time options for tee times
⋮----
// Zod validation schema
⋮----
type CreateListingFormValues = z.infer<typeof createListingSchema>;
⋮----
// Interface for user clubs from Supabase
interface UserClub {
  id: string;
  user_id: string;
  club_id: number;
  member_since: string;
  clubs: {
    id: number;
    name: string;
    location: string;
    description?: string;
  };
}
⋮----
// Redirect to login if not authenticated
⋮----
// Redirect if not a host
⋮----
// Fetch user's affiliated clubs using Supabase
⋮----
const onSubmit = (data: CreateListingFormValues) =>
⋮----
// Combine date and time into a single Date object
⋮----
// Validate that the date/time is in the future
⋮----
// Don't render anything while checking authentication
⋮----
// Loading state for clubs
⋮----
// Error state for clubs fetch
⋮----
// No clubs state
⋮----
<form onSubmit=
{/* Club Selection */}
⋮----
{/* Date and Time */}
⋮----
disabled=
⋮----
{/* Price and Players */}
⋮----
{/* Notes */}
⋮----
{/* Action Buttons */}
</file>

<file path="frontend/src/pages/pre-checkout.tsx">
import { useEffect, useState } from "react";
import { useParams, useLocation } from "wouter";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { AlertCircle, ArrowLeft, CalendarDays, Clock, Loader2, Users, Shield, Info } from "lucide-react";
import { formatDate, formatTime } from "@/lib/utils";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { useTeeTimeListing, useBookTeeTime, BookTeeTimeData } from "@/hooks/use-tee-times";
import { Helmet } from 'react-helmet';
⋮----
// Hook for creating the booking
⋮----
// Fetch tee time details
⋮----
// Load booking info from localStorage on mount
⋮----
// Redirect to login if not authenticated
⋮----
// Redirect if no booking info found
⋮----
// Verify booking info matches the current tee time
⋮----
const handleConfirmBooking = () =>
⋮----
// Verify tee time is still available
⋮----
// Create the booking record
⋮----
// Clear the localStorage
⋮----
// For MVP, navigate to dashboard (payment processing will be in M4)
// In M4, this would navigate to /checkout/:bookingId
⋮----
const guestFee = Math.round(totalPrice * 0.05 * 100) / 100; // 5% guest fee
⋮----
{/* Main Content */}
⋮----
{/* Tee Time Details */}
⋮----
{/* Host Information */}
⋮----
{/* Important Information */}
⋮----
{/* Action Button */}
⋮----

⋮----
{/* Booking Summary Sidebar */}
</file>

<file path="frontend/src/pages/tee-time-details.tsx">
import { useState } from "react";
import { useParams, useLocation } from "wouter";
import { useTeeTimeListing } from "@/hooks/use-tee-times";
import { useAuth } from "@/hooks/use-auth";
import { useBookTeeTime } from "@/hooks/use-tee-times";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { 
  Calendar, Clock, MapPin, Users, Star, MessageSquare, 
  AlertCircle, ChevronLeft, Check, Shield, Info, ArrowRight
} from "lucide-react";
import { formatDate, formatTime, formatPrice, getInitials } from "@/lib/utils";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from "@/components/ui/tabs";
import { Progress } from "@/components/ui/progress";
import { useToast } from "@/hooks/use-toast";
import { Helmet } from 'react-helmet';
⋮----
const handleBookNow = () =>
⋮----
// Can't book your own tee time
⋮----
// Check if tee time is available
⋮----
// Check for valid player count
⋮----
// Store booking information in localStorage temporarily
⋮----
guestId: user.id, // UUID from Supabase auth
⋮----
// Navigate to pre-checkout page for booking confirmation
⋮----
const handleContactHost = () =>
⋮----
const getHostInitials = () =>
⋮----
{/* Back button */}
⋮----
{/* Main content layout */}
⋮----
{/* Left column - Images and details */}
⋮----
{/* Club Image */}
⋮----
{/* Tabbed content for details */}
⋮----
{/* Details Tab */}
⋮----
{/* Host Tab */}
⋮----
{/* Removed member since text */}
⋮----
{/* Course Tab */}
⋮----
// If we have amenities from the API, use them
⋮----
<span>
⋮----
// Default amenities if none are provided
⋮----
{/* Right column - Booking card */}
</file>

<file path="frontend/src/pages/tee-times.tsx">
import { useState, useEffect } from "react";
import { useLocation } from "wouter";
import { useTeeTimeListings, TeeTimeSearchFilters } from "@/hooks/use-tee-times";
import { SearchFilters, SearchFilters as SearchFiltersType } from "@/components/listings/search-filters";
import TeeTimeCard from "@/components/listings/tee-time-card";
import SearchFiltersComponent from "@/components/listings/search-filters";
import { parseQueryParams } from "@/lib/utils";
import { Helmet } from 'react-helmet';
import { Button } from "@/components/ui/button";
import { MapPin, Filter, CalendarRange, Loader2, AlertCircle } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { format } from "date-fns";
⋮----
// Interface for Supabase tee time listing with joins
interface SupabaseTeeTimeListing {
  id: number; // serial primary key from schema
  host_id: string; // UUID from profiles table
  club_id: number; // serial primary key from clubs table
  date: string;
  price: number;
  players_allowed: number;
  notes?: string;
  status: string;
  created_at: string;
  clubs?: {
    id: number;
    name: string;
    location: string;
    image_url?: string;
  };
  host?: {
    id: string;
    first_name?: string;
    last_name?: string;
    username: string;
    profile_image_url?: string;
  };
}
⋮----
id: number; // serial primary key from schema
host_id: string; // UUID from profiles table
club_id: number; // serial primary key from clubs table
⋮----
// Popular locations users can quickly select
⋮----
// Parse the URL search parameters into filters state
const parseUrlFilters = () =>
⋮----
// Use window.location.search to get the current URL search parameters
⋮----
// Handle date parameter
⋮----
// Handle endDate parameter
⋮----
// These are already strings, no need to convert
// params.distance
// params.players
⋮----
// Re-evaluate filters when the URL location changes
⋮----
// Helper to quickly select a popular location
const selectLocation = (locationName: string) =>
⋮----
// Convert SearchFilters to TeeTimeSearchFilters for Supabase
⋮----
// Fetch tee time listings with filters from Supabase
⋮----
// Update URL when filters change
const handleSearch = (newFilters: SearchFilters) =>
⋮----
const toggleFavorite = (id: number) =>
⋮----
// This would normally update a user's favorites in the backend
⋮----
// TODO: Implement favorites functionality with Supabase
⋮----
{/* Popular Locations */}
⋮----
{/* Main Search Filters */}
⋮----
{/* Active Filters Display */}
⋮----

⋮----
{/* Loading, Error, and Results States */}
⋮----
id={teeTime.id} // Now correctly typed as number
⋮----
rating={0} // TODO: Add rating calculation from reviews
reviewCount={0} // TODO: Add review count from reviews
</file>

<file path="migrations/meta/_journal.json">
{
  "version": "7",
  "dialect": "postgresql",
  "entries": [
    {
      "idx": 0,
      "version": "7",
      "when": 1746810749215,
      "tag": "0000_ancient_nehzno",
      "breakpoints": true
    },
    {
      "idx": 1,
      "version": "7",
      "when": 1748961649685,
      "tag": "0001_left_barracuda",
      "breakpoints": true
    }
  ]
}
</file>

<file path="shared/schema.ts">
import { pgTable, text, serial, integer, boolean, timestamp, doublePrecision, jsonb, varchar, index, uuid } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
⋮----
// Session storage table for Replit Auth
⋮----
// Profiles table - links to Supabase auth.users via trigger
⋮----
id: uuid("id").primaryKey(), // Set by trigger to match auth.users(id)
username: text("username").unique(), // App-specific username
⋮----
id: true, // Required: the auth user UUID
⋮----
// Mark fields as optional for manual profile creation
⋮----
// Schema for profile updates (excludes id since it's immutable)
⋮----
// All fields optional for updates
⋮----
// Clubs that hosts are members of
⋮----
// Relationship between users and clubs (for member hosts)
⋮----
// Tee time listings
⋮----
status: text("status").notNull().default("available"), // available, pending, booked, cancelled
⋮----
// Bookings
⋮----
status: text("status").notNull().default("pending"), // pending, confirmed, completed, cancelled
⋮----
// Reminder fields
⋮----
// Reviews for hosts, guests and clubs
⋮----
targetId: text("target_id").notNull(), // Can be profile UUID or club integer ID (as text)
targetType: text("target_type").notNull(), // "host", "guest", "club"
⋮----
// Messages between hosts and guests
⋮----
// Notifications
⋮----
type: text("type").notNull(), // "booking", "message", "system"
relatedId: integer("related_id").notNull(), // ID of the related entity (booking, message, etc.)
⋮----
// Type exports
export type InsertProfile = z.infer<typeof insertProfileSchema>;
export type UpsertProfile = z.infer<typeof upsertProfileSchema>;
export type Profile = typeof profiles.$inferSelect;
⋮----
export type InsertClub = z.infer<typeof insertClubSchema>;
export type Club = typeof clubs.$inferSelect;
⋮----
export type InsertUserClub = z.infer<typeof insertUserClubSchema>;
export type UserClub = typeof userClubs.$inferSelect;
⋮----
export type InsertTeeTimeListing = z.infer<typeof insertTeeTimeListingSchema>;
export type TeeTimeListing = typeof teeTimeListing.$inferSelect;
⋮----
export type InsertBooking = z.infer<typeof insertBookingSchema>;
export type Booking = typeof bookings.$inferSelect;
⋮----
export type InsertReview = z.infer<typeof insertReviewSchema>;
export type Review = typeof reviews.$inferSelect;
⋮----
export type InsertMessage = z.infer<typeof insertMessageSchema>;
export type Message = typeof messages.$inferSelect;
⋮----
export type InsertNotification = z.infer<typeof insertNotificationSchema>;
export type Notification = typeof notifications.$inferSelect;
</file>

<file path="components.json">
{
    "$schema": "https://ui.shadcn.com/schema.json",
    "style": "default",
    "rsc": false,
    "tsx": true,
    "tailwind": {
      "config": "./tailwind.config.ts",
      "css": "./frontend/src/styles/global.css",
      "baseColor": "slate",
      "cssVariables": true,
      "prefix": ""
    },
    "aliases": {
      "components": "./frontend/src/components",
      "utils": "./frontend/src/lib/utils",
      "ui": "./frontend/src/components/ui"
    }
}
</file>

<file path="postcss.config.js">

</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";
</file>

<file path="tsconfig.json">
{
  "include": ["frontend/src/**/*", "shared/**/*", "backend/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./frontend/src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
import tailwindcss from "tailwindcss";
import autoprefixer from "autoprefixer";
</file>

<file path="frontend/src/components/auth/auth-modal.tsx">
import { useState } from "react";
import { Dialog, DialogContent, DialogTitle } from "@/components/ui/dialog";
import LoginForm from "./login-form";
import RegisterForm from "./register-form";
import PasswordResetForm from "./password-reset-form";
⋮----
interface AuthModalProps {
  isOpen: boolean;
  onClose: (result?: { emailVerificationPending?: boolean; email?: string }) => void;
  view: "login" | "register" | "reset-password";
  setView: (view: "login" | "register" | "reset-password") => void;
}
⋮----
// Determine the appropriate title based on the current view
const getTitle = () =>
⋮----
// Handle dialog close (without result)
const handleDialogClose = (open: boolean) =>
⋮----
onSuccess=
</file>

<file path="frontend/src/context/auth-context.tsx">
import { createContext, useEffect, useState, ReactNode, useContext } from "react";
import { useLocation } from "wouter";
import { ThemeProvider as NextThemesProvider } from "next-themes";
import { queryClient } from "@/lib/queryClient";
import { supabase } from "@/lib/supabaseClient";
import { useToast } from "@/hooks/use-toast";
import type { User as SupabaseUser } from '@supabase/supabase-js';
⋮----
// Extended User interface that includes both Supabase auth user and profile data
export interface User extends SupabaseUser {
  firstName?: string;
  lastName?: string;
  bio?: string;
  profileImage?: string;
  isHost: boolean;
  onboardingCompleted?: boolean;
  username?: string;
}
⋮----
interface RegisterData {
  email: string;
  password: string;
  firstName?: string;
  lastName?: string;
  isHost?: boolean;
  username?: string;
}
⋮----
interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (email: string, password: string) => Promise<void>;
  register: (data: RegisterData) => Promise<{ user: any; emailVerificationPending: boolean; email: string }>;
  logout: () => Promise<void>;
  openAuthModal: (view?: "login" | "register" | "reset-password") => void;
  refreshUserData: () => Promise<any>;
  requestPasswordReset: (email: string) => Promise<void>;
  updatePassword: (newPassword: string) => Promise<void>;
}
⋮----
interface AuthProviderProps {
  children: ReactNode;
  openAuthModal: (view?: "login" | "register" | "reset-password") => void;
}
⋮----
export function AuthProvider(
⋮----
// Helper function to merge Supabase user with profile data
const mergeUserWithProfile = async (supabaseUser: SupabaseUser): Promise<User> =>
⋮----
// Return user with basic info if profile fetch fails
⋮----
// Merge Supabase user data with profile data
⋮----
// Set up auth state change listener
⋮----
// User is signed in, fetch and merge profile data
⋮----
// User is signed out
⋮----
const login = async (email: string, password: string) =>
⋮----
const register = async (data: RegisterData) =>
⋮----
// Check if email verification is pending (session is null) or user is immediately signed in
⋮----
// User is immediately signed in
⋮----
// Email verification is pending
⋮----
// Fallback return (shouldn't reach here)
⋮----
const logout = async () =>
⋮----
// Even if the API call fails, clear user state on the client side
⋮----
const refreshUserData = async () =>
⋮----
// Invalidate related queries to ensure consistent data across components
⋮----
const requestPasswordReset = async (email: string) =>
⋮----
const updatePassword = async (newPassword: string) =>
⋮----
export function ThemeProvider(
⋮----
export function useAuth()
</file>

<file path="frontend/src/hooks/use-tee-times.tsx">
import { useQuery, useMutation } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { queryClient } from "@/lib/queryClient";
⋮----
export interface TeeTimeListing {
  id: number;
  hostId: number;
  clubId: number;
  date: string;
  price: number;
  playersAllowed: number;
  notes?: string;
  status: string;
  createdAt: string;
  host?: {
    id: number;
    username: string;
    firstName?: string;
    lastName?: string;
    profileImage?: string;
  };
  club?: {
    id: number;
    name: string;
    location: string;
    description?: string;
    imageUrl?: string;
  };
  hostRating: number;
  reviewCount: number;
}
⋮----
export interface TeeTimeBooking {
  id: number;
  teeTimeId: number;
  guestId: number;
  numberOfPlayers: number;
  status: string;
  stripePaymentIntentId?: string;
  createdAt: string;
  completedAt?: string;
  totalPrice: number;
  teeTime?: TeeTimeListing;
  guest?: {
    id: number;
    username: string;
    firstName?: string;
    lastName?: string;
    profileImage?: string;
  };
}
⋮----
export interface CreateTeeTimeData {
  hostId: string; // UUID for Supabase
  clubId: number;
  date: Date | string;
  price: number;
  playersAllowed: number;
  notes?: string;
}
⋮----
hostId: string; // UUID for Supabase
⋮----
export interface UpdateTeeTimeData {
  id: string; // UUID for Supabase tee time listing ID
  clubId?: number;
  date?: Date | string;
  price?: number;
  playersAllowed?: number;
  notes?: string | null;
  status?: string;
}
⋮----
id: string; // UUID for Supabase tee time listing ID
⋮----
export interface BookTeeTimeData {
  teeTimeId: number;
  guestId: string; // UUID for Supabase
  numberOfPlayers: number;
  totalPrice: number;
}
⋮----
guestId: string; // UUID for Supabase
⋮----
// Interface for search filters
export interface TeeTimeSearchFilters {
  location?: string;
  date?: Date;
  endDate?: Date;
  players?: string;
  distance?: string;
}
⋮----
// Fetch all available tee time listings with Supabase
export function useTeeTimeListings(filters?: TeeTimeSearchFilters)
⋮----
// Fetch a single tee time listing by ID
export function useTeeTimeListing(id?: number)
⋮----
// Fetch tee time listings by host ID
export function useHostTeeTimeListings(hostId?: number)
⋮----
// Fetch bookings for a user
export function useUserBookings(userId?: number)
⋮----
// Fetch bookings for a host
export function useHostBookings(hostId?: number)
⋮----
// Create a new tee time listing using Supabase
export function useCreateTeeTime()
⋮----
// Import supabase client
⋮----
// Prepare data for Supabase insertion
⋮----
// Invalidate relevant queries
⋮----
// Update an existing tee time listing using Supabase
export function useUpdateTeeTime()
⋮----
// Import supabase client
⋮----
// Prepare update data for Supabase (only include fields that are being updated)
⋮----
// Don't update if no fields are provided
⋮----
// Invalidate relevant queries
⋮----
// Create a preliminary booking record in Supabase with payment_pending status
export function useBookTeeTime()
⋮----
// Import supabase client
⋮----
// Step 1: Create booking record with payment_pending status
⋮----
// Step 2: Update tee time listing status to pending_payment
⋮----
// Don't throw here as booking creation was successful
⋮----
// Invalidate relevant Supabase queries
⋮----
// Update a booking status
export function useUpdateBookingStatus()
⋮----
// Create a payment intent for a booking (legacy)
export function useCreatePaymentIntent()
⋮----
// Create a direct payment intent without a booking first (new flow)
export interface DirectPaymentIntentData {
  amount: number;
  teeTimeId: number;
  metadata?: any;
}
⋮----
export function useCreateDirectPaymentIntent()
</file>

<file path="frontend/src/pages/basic-profile-edit.tsx">
import { useState, useRef } from "react";
import { useLocation } from "wouter";
import { useQuery, useMutation } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { useToast } from "@/hooks/use-toast";
import { queryClient } from "@/lib/queryClient";
import { supabase } from "@/lib/supabaseClient";
import { useAuth } from "@/hooks/use-auth";
import { Loader2, Camera, Upload } from "lucide-react";
import { Helmet } from 'react-helmet';
⋮----
// Interface for profile data from Supabase
interface ProfileData {
  id: string;
  username: string;
  first_name?: string;
  last_name?: string;
  bio?: string;
  profile_image_url?: string;
  is_host: boolean;
  onboarding_completed?: boolean;
  created_at: string;
  updated_at: string;
}
⋮----
// Interface for form data
interface ProfileUpdateData {
  first_name: string;
  last_name: string;
  bio?: string;
  profile_image_url?: string;
  updated_at: string;
}
⋮----
// Local state for form and image handling
⋮----
// Redirect if not authenticated
⋮----
// Fetch current profile data to pre-fill form
⋮----
// Pre-fill form fields with current data
⋮----
// Handle file selection and upload to Supabase Storage
const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) =>
⋮----
// Validate file type
⋮----
// Validate file size (5MB limit)
⋮----
// Generate unique file path: {userId}/profile.{extension}
⋮----
// Upload to Supabase Storage
⋮----
// Get public URL for the uploaded image
⋮----
// Update local state
⋮----
// Profile update mutation
⋮----
// Refresh user data in AuthContext
⋮----
// Invalidate related queries
⋮----
// Navigate back to profile page
⋮----
// Handle form submission
const handleSubmit = (e: React.FormEvent<HTMLFormElement>) =>
⋮----
// Validate required fields
⋮----
// Prepare update data
⋮----
// Add new profile image URL if one was uploaded
⋮----
// Loading state for initial profile fetch
⋮----
// Error state for profile fetch
⋮----
const getInitials = () =>
⋮----
{/* Profile Picture Section */}
⋮----
{/* Form Fields */}
⋮----
{/* Action Buttons */}
</file>

<file path="frontend/src/pages/dashboard.tsx">
import { useState } from "react";
import { useAuth } from "@/hooks/use-auth";
import { useUserBookings, useHostBookings, useUpdateTeeTime } from "@/hooks/use-tee-times";
import { useHostTeeTimeListingsSupabase } from "@/hooks/use-profile";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Separator } from "@/components/ui/separator";
import { Link, useLocation } from "wouter";
import { useToast } from "@/hooks/use-toast";
import { useUpdateBookingStatus } from "@/hooks/use-tee-times";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/components/ui/alert-dialog";
import { useCreatePaymentIntent } from "@/hooks/use-tee-times";
import { formatDate, formatTime } from "@/lib/utils";
import { CalendarDays, CheckCircle, Clock, Edit2, Volleyball, MessageSquare, Star, Users, Loader2, AlertCircle, Building, MapPin } from "lucide-react";
import { Helmet } from 'react-helmet';
import HostCalendar from "@/components/dashboard/host-calendar";
⋮----
// Interface for Supabase tee time listings
interface TeeTimeListing {
  id: string;
  host_id: string;
  club_id: number;
  date: string;
  price: number;
  players_allowed: number;
  notes?: string;
  status: string;
  created_at: string;
  clubs?: {
    id: number;
    name: string;
    location: string;
    image_url?: string;
  };
}
⋮----
// Redirect to login if not authenticated
⋮----
// Fetch data based on user role
⋮----
// Fetch host's tee time listings using Supabase
⋮----
const handleUpdateBookingStatus = (booking: any, status: string) =>
⋮----
const handleCapturePayment = (booking: any) =>
⋮----
const openDialog = (booking: any, action: 'cancel' | 'complete') =>
⋮----
const getStatusBadge = (status: string) =>
⋮----
const handleEditListing = (listingId: string) =>
⋮----
const handleCancelListing = (listingId: string) =>
⋮----
{/* Sidebar */}
⋮----
{/* My Listings Tab */}
⋮----
{/* Calendar view */}
⋮----
{/* Traditional list view */}
⋮----
<p><strong>Date:</strong>
⋮----
{/* Confirmation Dialog */}
</file>

<file path="frontend/src/pages/profile-onboarding.tsx">
import { useState, useRef, useEffect } from "react";
import { useLocation } from "wouter";
import { useQuery, useMutation } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useToast } from "@/hooks/use-toast";
import { queryClient } from "@/lib/queryClient";
import { supabase } from "@/lib/supabaseClient";
import { useAuth } from "@/hooks/use-auth";
import { useClubs, type Club } from "@/hooks/use-profile";
import { Loader2, Camera, Plus, MapPin, Building, ArrowRight, CheckCircle } from "lucide-react";
import { Helmet } from 'react-helmet';
⋮----
// Steps enum for onboarding flow
enum OnboardingStep {
  PROFILE = 'profile',
  CLUB_SELECTION = 'club_selection',
  COMPLETE = 'complete'
}
⋮----
// Interface for profile data from Supabase
interface ProfileData {
  id: string;
  username: string;
  first_name?: string;
  last_name?: string;
  bio?: string;
  profile_image_url?: string;
  is_host: boolean;
  onboarding_completed?: boolean;
  created_at: string;
  updated_at: string;
}
⋮----
// Interface for new club creation
interface NewClubData {
  name: string;
  location: string;
  description?: string;
}
⋮----
// Current step state
⋮----
// Profile form state
⋮----
// Club selection state
⋮----
// Redirect if not authenticated
⋮----
// Fetch current profile data to pre-fill form
⋮----
// Pre-fill form fields with current data
⋮----
// If profile is already completed, skip to dashboard
⋮----
// Fetch clubs for selection
⋮----
// Handle file selection and upload to Supabase Storage
const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) =>
⋮----
// Validate file type
⋮----
// Validate file size (5MB limit)
⋮----
// Generate unique file path: {userId}/profile.{extension}
⋮----
// Upload to Supabase Storage
⋮----
// Get public URL for the uploaded image
⋮----
// Update local state
⋮----
// Profile update mutation
⋮----
// Add new profile image URL if one was uploaded
⋮----
// Invalidate related queries
⋮----
// Move to next step based on user type
⋮----
// For guests, complete onboarding
⋮----
// Create new club mutation
⋮----
// Refresh clubs list
⋮----
// Select the newly created club
⋮----
// Reset form
⋮----
// Add user to club mutation
⋮----
// Invalidate related queries
⋮----
// Complete onboarding
⋮----
// Complete onboarding mutation
⋮----
// Navigate to dashboard
⋮----
// Helper function to complete onboarding
const completeOnboarding = () =>
⋮----
// Handle profile form submission
const handleProfileSubmit = (e: React.FormEvent<HTMLFormElement>) =>
⋮----
// Handle club selection
const handleClubSelection = () =>
⋮----
// Handle new club creation
const handleCreateClub = (e: React.FormEvent<HTMLFormElement>) =>
⋮----
// Skip club selection (for hosts who want to add it later)
const skipClubSelection = () =>
⋮----
// Loading state for initial profile fetch
⋮----
const getInitials = () =>
⋮----
const getStepTitle = () =>
⋮----
const getStepDescription = () =>
⋮----
{/* Progress Indicator */}
⋮----
{/* Profile Step */}
⋮----
{/* Profile Picture Section */}
⋮----

⋮----
{/* Bio Section */}
⋮----
{/* Submit Button */}
⋮----
{/* Club Selection Step */}
⋮----
{/* Existing Club Selection */}
⋮----
{/* Action Buttons */}
⋮----
/* New Club Form */
⋮----
required
</file>

<file path="frontend/src/pages/profile.tsx">
import { useState } from "react";
import { useParams, Link, useLocation } from "wouter";
import { useQuery } from "@tanstack/react-query";
import { useAuth } from "@/hooks/use-auth";
import { useUserClubs, useHostTeeTimeListingsSupabase, type UserClub, type TeeTimeListing } from "@/hooks/use-profile";
import { queryClient } from "@/lib/queryClient";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card, CardContent } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { Badge } from "@/components/ui/badge";
import TeeTimeCard from "@/components/listings/tee-time-card";
import { Calendar, Edit, MessageSquare, Star, MapPin } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { formatDate } from "@/lib/utils";
import { Helmet } from 'react-helmet';
⋮----
// Interface for raw Supabase profile data (snake_case)
interface SupabaseProfile {
  id: string;
  username: string;
  first_name?: string;
  last_name?: string;
  bio?: string;
  profile_image_url?: string;
  is_host: boolean;
  onboarding_completed?: boolean;
  created_at: string;
  updated_at: string;
}
⋮----
// Interface for reviews from Supabase
interface Review {
  id: string;
  reviewer_id: string;
  target_id: string;
  target_type: 'host' | 'guest' | 'club';
  rating: number;
  comment?: string;
  created_at: string;
  reviewer?: {
    id: string;
    username: string;
    first_name?: string;
    last_name?: string;
    profile_image_url?: string;
  };
}
⋮----
const userId = id; // Keep as string since Supabase uses UUIDs
⋮----
// Fetch user profile data using Supabase
⋮----
staleTime: 30 * 1000, // 30 seconds
⋮----
// Fetch user clubs if the user is a host
⋮----
// Fetch user's tee time listings if they are a host
⋮----
// Fetch reviews about the user
⋮----
const getInitials = () =>
⋮----
const handleMessageClick = () =>
⋮----
{/* Profile sidebar */}
⋮----
{/* Profile main content */}
</file>

<file path=".gitignore">
# Environment variables
# Ensure this is present to protect your secrets!
.env
.env.*
!.env.example # If you have an example env file, don't ignore it

# Node.js
node_modules/
npm-debug.log*
yarn-error.log*
pnpm-debug.log*
package-lock.json # Usually committed, but some teams ignore if only using yarn.lock or pnpm-lock.yaml. For npm, commit it.
yarn.lock # If using Yarn
pnpm-lock.yaml # If using PNPM

# Build output
dist/
build/ # Common build output folder name, good to have
out/   # Another common one

# Operating System generated files
.DS_Store
Thumbs.db
._*

# Editor/IDE specific
.vscode/
.idea/
*.sublime-project
*.sublime-workspace
.fleet/

# Cursor editor specific (keep if you want to commit rules, otherwise ignore)
# .cursor/  <-- You have rules here, so maybe don't ignore the whole folder
.cursor/tempHistory/ # Example if Cursor creates temp files you don't want

# Log files
*.log
logs/
*.log.*

# Test Results / Coverage
coverage/
junit.xml
.nyc_output/

# Drizzle Kit generated files (besides migrations which SHOULD be committed)
# Drizzle studio session files if you use it locally
# .drizzle/studio/ # Example, check actual name if Drizzle Studio creates local files

# Temporary files
*.tmp
*.swp
*~

# Supabase local development (if you ever use Supabase CLI for local dev)
.supabase/

# SpecStory (You have this ignored in your .cursorindexingignore for Cursor,
# but for Git, you probably want to commit your .specstory/history/ and .specstory/.gitignore
# If you want to ignore the whole .specstory folder from Git, uncomment the next line)
# .specstory/
# However, your .specstory/.gitignore already ignores ".what-is-this.md", which is good.

# Specific files from your project listing that should likely be ignored if not already:
# (Assuming these were temporary or generated and not essential to commit)
# If `generated-icon.png` is truly generated by a build step and not a source asset:
# frontend/public/generated-icon.png # (Adjust path if it's elsewhere)

# Comment out if you decide to keep `attached_assets` and its contents in repo for some reason
# attached_assets/

# If there are other specific generated files from your build or dev process, add them.
.specstory/history/2025-06-04_23-08-improve-email-verification-user-experience.md
</file>

<file path="package.json">
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "NODE_ENV=development tsx backend/index.ts",
    "build": "vite build && esbuild backend/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@paypal/paypal-server-sdk": "^1.0.0",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@sendgrid/mail": "^8.1.5",
    "@stripe/react-stripe-js": "^3.7.0",
    "@stripe/stripe-js": "^7.3.0",
    "@supabase/supabase-js": "^2.49.9",
    "@tanstack/react-query": "^5.60.5",
    "@types/memoizee": "^0.4.12",
    "@types/node-schedule": "^2.1.7",
    "@types/passport-facebook": "^3.0.3",
    "@types/passport-google-oauth20": "^2.0.16",
    "@types/pg": "^8.15.4",
    "alpinejs": "^3.14.9",
    "axios": "^1.9.0",
    "bcryptjs": "^3.0.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-mongo": "^5.1.0",
    "connect-pg-simple": "^10.0.0",
    "date-fns": "^3.6.0",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.6.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "firebase": "^11.7.1",
    "firebase-admin": "^13.3.0",
    "framer-motion": "^11.13.1",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.453.0",
    "memoizee": "^0.4.17",
    "memorystore": "^1.6.7",
    "mongodb": "^6.16.0",
    "next-themes": "^0.4.6",
    "node-schedule": "^2.1.1",
    "openid-client": "^6.5.0",
    "passport": "^0.7.0",
    "passport-apple": "^2.0.2",
    "passport-facebook": "^3.0.0",
    "passport-google-oauth20": "^2.0.0",
    "passport-local": "^1.0.0",
    "pg": "^8.16.0",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-helmet": "^6.1.0",
    "react-hook-form": "^7.55.0",
    "react-icons": "^5.4.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.2",
    "stripe": "^18.1.0",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.2.5",
    "vaul": "^1.1.2",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.24.2",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.1.2",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@tailwindcss/vite": "^4.1.3",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.1",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.30.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.14"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}
</file>

<file path="frontend/src/components/auth/register-form.tsx">
import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useToast } from "@/hooks/use-toast";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useAuth } from "@/hooks/use-auth";
import { Loader2 } from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
⋮----
type RegisterFormValues = z.infer<typeof registerSchema>;
⋮----
interface RegisterFormProps {
  onSuccess: (result?: { emailVerificationPending?: boolean; email?: string }) => void;
  switchToLogin: () => void;
}
⋮----
// Use either the auth context loading state or local submitting state
⋮----
async function onSubmit(data: RegisterFormValues)
⋮----
// Call the auth context register function with the correct data structure
// This will pass the metadata to Supabase's options.data
⋮----
// username is optional and can be generated by the trigger if not provided
⋮----
// Show success toast only if user is immediately signed in
// Email verification pending cases are handled by CheckEmailModal
⋮----
// Call the success callback with registration result information
⋮----
// Handle specific Supabase auth errors
⋮----
// Set form-level error for immediate user feedback
⋮----
// Also show toast for consistency
⋮----
<form onSubmit=
{/* Display form-level errors */}
</file>

<file path="frontend/src/App.tsx">
import { useState, useEffect } from "react";
import { Switch, Route, useLocation, useRoute, Redirect } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { ThemeProvider } from "@/context/auth-context";
import { AuthProvider } from "@/context/auth-context";
import { useAuth } from "@/hooks/use-auth";
import { ChatProvider } from "@/context/chat-context";
import ScrollRestoration from "@/components/scroll-restoration";
import Navbar from "@/layouts/Navbar";
import Footer from "@/layouts/Footer";
import NotFound from "@/pages/not-found";
import Home from "@/pages/home";
import TeeTimesPage from "@/pages/tee-times";
import TeeTimeDetailsPage from "@/pages/tee-time-details";
import ProfilePage from "@/pages/profile";
import ProfileOnboarding from "@/pages/profile-onboarding";
import ProfileEdit from "@/pages/profile-edit";
import BasicProfileEdit from "@/pages/basic-profile-edit";
import Dashboard from "@/pages/dashboard";
import CreateListing from "@/pages/create-listing";
import EditListingPage from "@/pages/EditListingPage";
import CheckoutPage from "@/pages/checkout";
import PreCheckoutPage from "@/pages/pre-checkout";
import MessagesPage from "@/pages/messages";
import NotificationsPage from "@/pages/notifications";
import AboutPage from "@/pages/about";
import PressPage from "@/pages/press";
import PrivacyPolicyPage from "@/pages/privacy-policy";
import TermsOfServicePage from "@/pages/terms-of-service";
import CookiePolicyPage from "@/pages/cookie-policy";
import ContactPage from "@/pages/contact";
import HelpPage from "@/pages/help";
import UpdatePasswordPage from "@/pages/UpdatePasswordPage";
import AuthModal from "@/components/auth/auth-modal";
import CheckEmailModal from "@/components/auth/CheckEmailModal";
import SanityCheckComponent from "@/components/_dev_examples/SanityCheckComponent";
import { Loader2 } from "lucide-react";
⋮----
// Protected Route component
⋮----
// Debug information
⋮----
// Check if user needs to complete onboarding
⋮----
// Host Only Route component
⋮----
// Determine if navbar and footer should be shown
⋮----
// Handle onboarding redirection and query parameter auth modal
⋮----
// Parse query parameters
⋮----
// Handle auth query parameter (e.g., ?auth=reset-password)
⋮----
// Clean up URL by removing query parameter
⋮----
// Important: Return early here if we opened a modal, so we don't immediately try to redirect for onboarding
⋮----
// Handle onboarding redirection for authenticated users
⋮----
// Periodically refresh user data to ensure profile updates are reflected everywhere
⋮----
// Initial refresh
⋮----
// Set up a periodic refresh every 60 seconds to ensure data consistency
⋮----
// Clean up interval on component unmount
⋮----
{/* Password Reset Page - No auth required, handles its own session validation */}
⋮----
{/* Sanity Check Route for Testing TanStack Query + Supabase Integration */}
⋮----
{/* Onboarding routes */}
⋮----
{/* Protected routes */}
⋮----
{/* Host-only routes */}
⋮----
{/* Standard pages */}
⋮----
// Open auth modal function to be passed to context and Router
const openAuthModal = (view: "login" | "register" | "reset-password" = "login") =>
⋮----
const closeAuthModal = (result?:
⋮----
setIsAuthModalOpen(false); // Close the main AuthModal
⋮----
setShowCheckEmailModal(true); // Trigger the new "Check Email" modal
</file>

<file path="README.md">
# ClubKey - Golf Teesss Time Marketplace

A modern web platform connecting golf enthusiasts with exclusive club tee times, offering an intuitive and seamless booking experience.

## Overview

Linx is a marketplace for Golf Foursomes, similar to AirBNB or SeatGeek but specialized for golf. The platform allows Golf Club members to register as hosts and list available tee times, while golfing guests can search for and purchase these tee times.

## Tech Stack

- **Frontend**: HTML/CSS with Alpine.js for interactivity
- **Backend**: Node.js + Express
- **Database**: MongoDB
- **Authentication**: Firebase Authentication
- **Storage**: Firebase Storage
- **Payments**: Stripe Connect with 24-hour escrow system

## Features

- **User Authentication**: Secure login/signup with email/password and Google Authentication
- **User Profiles**: Detailed profiles for both hosts and guests
- **Tee Time Listings**: Search, filter, and book tee times
- **Secure Payments**: Stripe integration for secure transactions with escrow system
- **Reviews & Ratings**: Build reputation and trust through reviews
- **Notifications**: Both in-app and email notifications
- **Responsive Design**: Works on all devices from mobile to desktop

## Getting Started

### Prerequisites

1. Node.js (v14+)
2. MongoDB
3. Firebase project with Authentication enabled
4. Stripe account
5. SendGrid account (for email notifications)

### Environment Variables

Create a `.env` file in the root directory with the following variables:

```
# MongoDB
MONGODB_URI=your_mongodb_connection_string

# Firebase
FIREBASE_API_KEY=your_firebase_api_key
FIREBASE_AUTH_DOMAIN=your_project_id.firebaseapp.com
FIREBASE_PROJECT_ID=your_project_id
FIREBASE_STORAGE_BUCKET=your_project_id.appspot.com
FIREBASE_MESSAGING_SENDER_ID=your_messaging_sender_id
FIREBASE_APP_ID=your_app_id
FIREBASE_SERVICE_ACCOUNT=your_service_account_json_stringified

# Stripe
STRIPE_SECRET_KEY=your_stripe_secret_key
STRIPE_WEBHOOK_SECRET=your_stripe_webhook_secret

# SendGrid
SENDGRID_API_KEY=your_sendgrid_api_key

# Session
SESSION_SECRET=your_session_secret
```

### Installation

1. Clone the repository
2. Install dependencies
   ```
   npm install
   ```
3. Start the server
   ```
   npm run dev
   ```
4. Visit `http://localhost:5000` in your browser

## Firebase Setup

1. Create a Firebase project at [firebase.google.com](https://firebase.google.com)
2. Enable Authentication with email/password and Google sign-in methods
3. Enable Firebase Storage
4. Create a web app in your Firebase project and get the config values
5. Add your Replit domain to the Authorized Domains in Authentication settings

## MongoDB Setup

1. Create a MongoDB Atlas cluster or use a local MongoDB instance
2. Create a database named "linxGolf"
3. Update the `MONGODB_URI` in your .env file

## Stripe Setup

1. Create a Stripe account at [stripe.com](https://stripe.com)
2. Get your API keys from the Stripe Dashboard
3. Set up Connect accounts for hosts to receive payments
4. Create a webhook endpoint for payment events

## API Routes

### Authentication
- `POST /api/auth/register` - Register a new user
- `POST /api/auth/login` - Login a user
- `POST /api/auth/logout` - Logout a user
- `GET /api/auth/me` - Get current user

### Tee Times
- `GET /api/tee-times` - Get all tee time listings
- `GET /api/tee-times/:id` - Get a specific tee time listing
- `POST /api/tee-times` - Create a new tee time listing (host only)
- `PATCH /api/tee-times/:id` - Update a tee time listing (host only)

### Bookings
- `GET /api/bookings/guest/:guestId` - Get bookings for a guest
- `GET /api/bookings/tee-time/:teeTimeId` - Get bookings for a tee time (host only)
- `POST /api/bookings` - Create a new booking
- `PATCH /api/bookings/:id/status` - Update booking status

### Reviews
- `GET /api/reviews/target/:targetId` - Get reviews for a target (host/guest)
- `POST /api/reviews` - Create a new review

### Payments
- `POST /api/payments/create-intent` - Create a payment intent
- `POST /api/webhook` - Stripe webhook endpoint

## Project Structure

```
/
├── public/                # Static assets and client-side code
│   ├── css/               # CSS stylesheets
│   ├── js/                # JavaScript files
│   ├── images/            # Image assets
│   └── index.html         # Main HTML file with Alpine.js components
├── server/                # Server-side code
│   ├── db.js              # MongoDB connection
│   ├── firebase.js        # Firebase configuration
│   ├── firebase-auth.js   # Authentication middleware
│   ├── mongo-storage.js   # Data storage implementation
│   ├── new-express-app.js # Express app configuration
│   ├── new-index.js       # Server entry point
│   ├── new-routes.js      # API routes
│   └── new-reminder-service.js # Reminder service
└── shared/                # Shared code between client and server
    └── schema.ts          # Database schema
```

## License

[MIT](LICENSE)

## Contributors

- Replit AI - Technical Implementation

## Contact

For any questions or feedback, please contact [info@linx-golf.com](mailto:info@linx-golf.com).
</file>

<file path="vercel.json">
{
  "buildCommand": "npm run build",
  "outputDirectory": "dist/public",
  "installCommand": "npm install",
  "devCommand": "npm run dev",
  "framework": null,
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/index.html"
    }
  ]
}
</file>

</files>
